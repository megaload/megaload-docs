{
    "docs": [
        {
            "location": "/", 
            "text": "a scalable load testing tool by \nErlang Solutions\n\n\n\n\n\n\nWhat is Megaload?\n\n\nMegaload is a scalable load testing tool that provides automatic deployment on cloud environments, allowing you to simulate a massive amount of load to stress test your system. The powerful real time measurement system provides all the information needed to monitor load tests through the graphical user interface.\n\n\n\n\nMulti-protocol\n Test web services and RESTful APIs using the built-in HTTP plugin. Test XMPP servers using Erlang scripts.\n\n\nBrowser user interface\n The Web UI manages all aspects of the load test and displays real time metrics. Alternatively, the HTTP API provides all the management features.\n\n\nReal-time measurements\n The web UI provides counters and histograms measuring all aspects of your systems. Visualise total values, averages, medians or percentiles.\n\n\nDeployment\n Megaload ofers automatic cloud deployment with minimal setup efort. Multi-core and cluster scalability. Get the maximum performance with minimum cost.\n\n\nHTTP testing\n Response handling with JsonPath, Cookie handling, HTTP redirect, persistent connections, Keep-Alive handling, SSL support, Chunked Transfer-Encoding support. The integrated IP load balancing allows Megaload to round-robin between IPs and provide individual measures of each of your servers.\n\n\nDSL\n Write your test specifications using JSON. Combine diferent user and load profiles in a single test. Define assertions indicating the success conditions based on the metrics.\n\n\n\n\nMegaload is designed to be extended, by adding any standard or custom protocol. This makes it highly customisable to fit your project needs. Please contact us if you want to know more about our testing services.\n\n\nArchitecture\n\n\nMegaload lets you simulate a massive amount of load to stress test your system. The standard Megaload product can increase its load testing capacity by adding more instances to generate the desired load. At the moment, this feature is not available in the Amazon Marketplace platform, but we are working to support it.\n\n\nMegaload comprises two components:\n\n\n\n\nMegaloadUI\n is the frontend instance that gathers all the metrics and manages the load\n\n\nMegaload\n is the load engine instance that generates the load\n\n\n\n\nTo get started with Megaload, you must first purchase Megaload in the Amazon Marketplace. The Megaload instance contains both components ready to use. Each instance (c3.2xlarge) can provide up to 100,000 concurrent users. See the \nAmazon Marketplace page\n for pricing and additional details.\n\n\nProperty-based testing\n\n\nMegaload was developed within the research project \nPROWESS\n as a cloud testing framework. We contribute to the research in load testing by applying property-based testing to the generation of load profiles. Property-based testing creates many different load profiles and when the system becomes overloaded it finds the exact load profile through shrinking. The PROWESS partners developed new properties that measure the service degradation under heavy load by means of the latency and throughput of the system. The new testing strategies were successfully applied, reducing the time spent on testing by minimising the number of test cases executed. Contact us if you want to know more about this feature.\n\n\nNeed help?\n\n\nWe're always happy to help out with your load tests or any other question you might have. Contact us at \nmegaload@erlang-solutions.com\n for more information.", 
            "title": "Overview"
        }, 
        {
            "location": "/#what-is-megaload", 
            "text": "Megaload is a scalable load testing tool that provides automatic deployment on cloud environments, allowing you to simulate a massive amount of load to stress test your system. The powerful real time measurement system provides all the information needed to monitor load tests through the graphical user interface.   Multi-protocol  Test web services and RESTful APIs using the built-in HTTP plugin. Test XMPP servers using Erlang scripts.  Browser user interface  The Web UI manages all aspects of the load test and displays real time metrics. Alternatively, the HTTP API provides all the management features.  Real-time measurements  The web UI provides counters and histograms measuring all aspects of your systems. Visualise total values, averages, medians or percentiles.  Deployment  Megaload ofers automatic cloud deployment with minimal setup efort. Multi-core and cluster scalability. Get the maximum performance with minimum cost.  HTTP testing  Response handling with JsonPath, Cookie handling, HTTP redirect, persistent connections, Keep-Alive handling, SSL support, Chunked Transfer-Encoding support. The integrated IP load balancing allows Megaload to round-robin between IPs and provide individual measures of each of your servers.  DSL  Write your test specifications using JSON. Combine diferent user and load profiles in a single test. Define assertions indicating the success conditions based on the metrics.   Megaload is designed to be extended, by adding any standard or custom protocol. This makes it highly customisable to fit your project needs. Please contact us if you want to know more about our testing services.", 
            "title": "What is Megaload?"
        }, 
        {
            "location": "/#architecture", 
            "text": "Megaload lets you simulate a massive amount of load to stress test your system. The standard Megaload product can increase its load testing capacity by adding more instances to generate the desired load. At the moment, this feature is not available in the Amazon Marketplace platform, but we are working to support it.  Megaload comprises two components:   MegaloadUI  is the frontend instance that gathers all the metrics and manages the load  Megaload  is the load engine instance that generates the load   To get started with Megaload, you must first purchase Megaload in the Amazon Marketplace. The Megaload instance contains both components ready to use. Each instance (c3.2xlarge) can provide up to 100,000 concurrent users. See the  Amazon Marketplace page  for pricing and additional details.", 
            "title": "Architecture"
        }, 
        {
            "location": "/#property-based-testing", 
            "text": "Megaload was developed within the research project  PROWESS  as a cloud testing framework. We contribute to the research in load testing by applying property-based testing to the generation of load profiles. Property-based testing creates many different load profiles and when the system becomes overloaded it finds the exact load profile through shrinking. The PROWESS partners developed new properties that measure the service degradation under heavy load by means of the latency and throughput of the system. The new testing strategies were successfully applied, reducing the time spent on testing by minimising the number of test cases executed. Contact us if you want to know more about this feature.", 
            "title": "Property-based testing"
        }, 
        {
            "location": "/#need-help", 
            "text": "We're always happy to help out with your load tests or any other question you might have. Contact us at  megaload@erlang-solutions.com  for more information.", 
            "title": "Need help?"
        }, 
        {
            "location": "/qs_full/", 
            "text": "Purchasing and accessing Megaload\n\n\nTo get started with Megaload, you must first purchase Megaload in the Amazon Web Services Marketplace.\n\n\n\n\nGo to the \nAWS Marketplace\n and search for \"Megaload\".\n\n\nSelect \"Megaload Load Testing\" from the search results.\n\n\nReview the information on Megaload Load Testing page, and then click \nContinue\n.\n\nFollow the steps in Amazon to complete the purchase.\n\n\n\n\nThe Megaload instance contains all components ready to use. To start using Megaload:\n\n\n\n\nLaunch MegaloadUI via 1-click. \n\n\nAccess the application via your web browser at \nhttp://\nEC2_Instance_Public_DNS\n:8080/index.html\n.  \n\n\n\n\nLog in using the username \u201cadmin\u201d and the \ninstance_id\n of the instance without '-' as the password.\n\n\n\n\n\n\nGetting started with Megaload\n\n\nWriting a Megaload test\n\n\nMegaload supports two types of test specifications for load testing. Tests for HTTP interfaces can be written in JSON, while tests for XMPP are written in plain \nErlang\n. To get you started with the tests, look at the following HTTP example:\n\n\n[{\ntest\n : {\nid\n : \nMyFirstTest\n,\n            \nphases\n : [\nPhase1\n],\n            \nplugins\n : [\nServer1\n]\n           }},\n\n {\nplugin\n : {\nid\n : \nServer1\n,\n              \nplugin_info\n : {\nhttp-plugin\n : {\nservers\n : [{\nhost\n : \n10.100.0.120\n,\n                                                              \nport\n : 5050,\n                                                              \nssl\n : false}\n                                                            ],\n                                                \nstats_per_url\n : true\n                                               }}\n             }},\n\n {\nphase\n : {\nid\n : \nPhase1\n,\n             \narrival_rate\n : 10,\n             \nduration\n : 600000,\n             \nconcurrent_scenarios\n : 250,\n             \nrate\n : 500,\n             \nscenarios\n : [{\nScenario1\n : 1}]}},\n\n {\nscenario\n : {\nid\n : \nScenario1\n,\n                \nkeepalive\n : true,\n                \nactions\n : [ {\nhttp-request\n : {\nplugin_id\n : \nServer1\n,\n                                                 \nmethod\n : \nGET\n,\n                                                 \npath\n : \n/index.html\n\n                                                }\n                              }]}}\n]\n\n\n\n\nIn this test case:\n\n\n\n\nduration\n runs for 10 minutes (600000 milliseconds)\n\n\narrival_rate\n starts 10 new users per second, up to 250 concurrent users\n\n\nrate\n generates 500 requests per second\n\n\nkeepalive\n users stay connected to the HTTP server and repeat the same \nhttp-request\n GET \"/index.html\" for the duration of the phase\n\n\n\n\nDashboard\n\n\nThere are two main dashboards for controlling Megaload: \n\n\n\n\nLoad testing\n provides all the facilities to edit, upload and execute test cases \n\n\nMonitoring\n provides real-time metrics of the system\n\n\n\n\nTo access the \nLoad testing\n dashboard, go to \nhttp://\nEC2_Instance_Public_DNS\n:8080/megaload/index.html\n. The primary navigation bar provides two main menus, \nLoad generators\n and \nLoad test\n.\n\n\nThe \nLoad generators\n page shows the Megaload instances that have been deployed. In the following example there is one Megaload generator \nMegaload 1.0.1\n, which consists of one load engine (Megaload node).\n\n\n\n\nThe next sections explain step by step how to use the \nLoad test\n functionality to write, upload and execute load test.\n\n\nEditing JSON tests\n\n\nThe \nEdit test cases\n tab provides a JSON test editor that does basic syntactic checks to help you write test specifications. To view the editor, first select the Megaload generator on the left. This will show the editor on the right, containing the test specification that is currently loaded.\n\n\n\n\n\n\nNote that using the editor is not obligatory. You can write your tests in any text editor of your choice, and then \nupload\n the files directly to Megaload. If you need to do further editing, you can \nopen\n your files in the editor and make changes there.\n\n\nTry to edit the previous example by replacing the server in the \nhttp-plugin\n object with a server you want to test. You may also amend the \npath\n of the \nhttp-request\n.\n\n\nLoading a JSON test\n\n\nThe \nLoad test\n page provides all the functionality required to upload and run tests.\n\n\nTo upload a test specification:\n\n\n\n\nClick the \nUpload test cases\n tab.\n\n\nClick the load generator on the left. This shows the upload menu on the right.\n\n\nClick \nAdd files\n and select the files to upload.\n\n\nClick \nStart upload\n or \nStart\n to upload the individual files.\n\n   The status shows as \nUploaded\n or, if the test specification is invalid, \nError\n. If an error occurs, a pop-up window will show the reason.\n\n\n\n\n\n\nRunning a test\n\n\nThe \nRunner\n tab provides the controls to start and stop a test.\n\n\nTo run a test:\n\n\n\n\nClick the load generator on the left. This shows the test control menu on the right.\n\n\nSelect the test identifier from the drop-down list next to the \nStart\n button.\n\n\nClick \nStart\n.\n\n\n\n\nThe following screenshot shows a test that has been started:\n\n\n\n\nViewing test results\n\n\nThe \nLoad report\n tab provides a summary of the test being executed. The \nLoad report\n consists of six tabs with additional information, the main ones are:\n\n\n\n\n\n\nStatus\n shows the current status of the test, which can be one of the following: \nRunning\n, \nFinished\n or \nStopped\n. The status \nStopped\n is shown when the user clicks on \nStop\n in the \nRunner\n tab.\n\n\n\n\n\n\n\n\nResponse time\n shows a statistical report about the response time of the current protocol (selected using the drop-down buttons) in the selected load engine. At the bottom of the page, there is a table with the response time per URL requested. Statistics will show up approximately one minute after test start.\n\n\n\n\n\n\n\n\nRate\n shows a statistical report about the rate of requests in the selected load engine.\n\n\n\n\n\n\n\n\nStatistics\n provides a direct link to the full metrics dashboard, also accessible from the \nMonitoring\n link at the top of the page.\n\n\n\n\n\n\nReal-time metrics\n\n\nThe \nMonitoring\n dashboard provides all the real-time metrics under \nhttp://\nEC2_Instance_Public_DNS\n:8080/#/metrics\n.\n\n\nThe \nCollected Metrics\n tab displays the load generator and its load engines on the left.\n\n\n\n\n\n\n\n\nThe load generator, \nMegaload 1.0.1\n aggregates the counters from all the load engines, displaying metrics such as the number of scenarios or sucessful requests for the whole system. Click the name to display the drop-down menu with the full list of available metrics. For example, select \nglobal_counter_scenarios\n and check the concurrent users. The next images shows a custom deployment with two load engines.\n\n\n\n\n\n\n\n\nBelow the load generator are all the load engines that have been deployed. Select one of them to display the drop-down menu containing counters and histograms. For example, select \nCounters and Gauges\n and check the concurrent users for that node.\n\n\n\n\n\n\n\n\nHistograms\n provide information about response times, connection times or requests per second on each of the individual load engines. All these measurements and their units are described in detail in the \nCounters\n section.", 
            "title": "Quick start"
        }, 
        {
            "location": "/qs_full/#purchasing-and-accessing-megaload", 
            "text": "To get started with Megaload, you must first purchase Megaload in the Amazon Web Services Marketplace.   Go to the  AWS Marketplace  and search for \"Megaload\".  Select \"Megaload Load Testing\" from the search results.  Review the information on Megaload Load Testing page, and then click  Continue . \nFollow the steps in Amazon to complete the purchase.   The Megaload instance contains all components ready to use. To start using Megaload:   Launch MegaloadUI via 1-click.   Access the application via your web browser at  http:// EC2_Instance_Public_DNS :8080/index.html .     Log in using the username \u201cadmin\u201d and the  instance_id  of the instance without '-' as the password.", 
            "title": "Purchasing and accessing Megaload"
        }, 
        {
            "location": "/qs_full/#getting-started-with-megaload", 
            "text": "", 
            "title": "Getting started with Megaload"
        }, 
        {
            "location": "/qs_full/#writing-a-megaload-test", 
            "text": "Megaload supports two types of test specifications for load testing. Tests for HTTP interfaces can be written in JSON, while tests for XMPP are written in plain  Erlang . To get you started with the tests, look at the following HTTP example:  [{ test  : { id  :  MyFirstTest ,\n             phases  : [ Phase1 ],\n             plugins  : [ Server1 ]\n           }},\n\n { plugin  : { id  :  Server1 ,\n               plugin_info  : { http-plugin  : { servers  : [{ host  :  10.100.0.120 ,\n                                                               port  : 5050,\n                                                               ssl  : false}\n                                                            ],\n                                                 stats_per_url  : true\n                                               }}\n             }},\n\n { phase  : { id  :  Phase1 ,\n              arrival_rate  : 10,\n              duration  : 600000,\n              concurrent_scenarios  : 250,\n              rate  : 500,\n              scenarios  : [{ Scenario1  : 1}]}},\n\n { scenario  : { id  :  Scenario1 ,\n                 keepalive  : true,\n                 actions  : [ { http-request  : { plugin_id  :  Server1 ,\n                                                  method  :  GET ,\n                                                  path  :  /index.html \n                                                }\n                              }]}}\n]  In this test case:   duration  runs for 10 minutes (600000 milliseconds)  arrival_rate  starts 10 new users per second, up to 250 concurrent users  rate  generates 500 requests per second  keepalive  users stay connected to the HTTP server and repeat the same  http-request  GET \"/index.html\" for the duration of the phase", 
            "title": "Writing a Megaload test"
        }, 
        {
            "location": "/qs_full/#dashboard", 
            "text": "There are two main dashboards for controlling Megaload:    Load testing  provides all the facilities to edit, upload and execute test cases   Monitoring  provides real-time metrics of the system   To access the  Load testing  dashboard, go to  http:// EC2_Instance_Public_DNS :8080/megaload/index.html . The primary navigation bar provides two main menus,  Load generators  and  Load test .  The  Load generators  page shows the Megaload instances that have been deployed. In the following example there is one Megaload generator  Megaload 1.0.1 , which consists of one load engine (Megaload node).   The next sections explain step by step how to use the  Load test  functionality to write, upload and execute load test.  Editing JSON tests  The  Edit test cases  tab provides a JSON test editor that does basic syntactic checks to help you write test specifications. To view the editor, first select the Megaload generator on the left. This will show the editor on the right, containing the test specification that is currently loaded.    Note that using the editor is not obligatory. You can write your tests in any text editor of your choice, and then  upload  the files directly to Megaload. If you need to do further editing, you can  open  your files in the editor and make changes there.  Try to edit the previous example by replacing the server in the  http-plugin  object with a server you want to test. You may also amend the  path  of the  http-request .  Loading a JSON test  The  Load test  page provides all the functionality required to upload and run tests.  To upload a test specification:   Click the  Upload test cases  tab.  Click the load generator on the left. This shows the upload menu on the right.  Click  Add files  and select the files to upload.  Click  Start upload  or  Start  to upload the individual files. \n   The status shows as  Uploaded  or, if the test specification is invalid,  Error . If an error occurs, a pop-up window will show the reason.    Running a test  The  Runner  tab provides the controls to start and stop a test.  To run a test:   Click the load generator on the left. This shows the test control menu on the right.  Select the test identifier from the drop-down list next to the  Start  button.  Click  Start .   The following screenshot shows a test that has been started:   Viewing test results  The  Load report  tab provides a summary of the test being executed. The  Load report  consists of six tabs with additional information, the main ones are:    Status  shows the current status of the test, which can be one of the following:  Running ,  Finished  or  Stopped . The status  Stopped  is shown when the user clicks on  Stop  in the  Runner  tab.     Response time  shows a statistical report about the response time of the current protocol (selected using the drop-down buttons) in the selected load engine. At the bottom of the page, there is a table with the response time per URL requested. Statistics will show up approximately one minute after test start.     Rate  shows a statistical report about the rate of requests in the selected load engine.     Statistics  provides a direct link to the full metrics dashboard, also accessible from the  Monitoring  link at the top of the page.", 
            "title": "Dashboard"
        }, 
        {
            "location": "/qs_full/#real-time-metrics", 
            "text": "The  Monitoring  dashboard provides all the real-time metrics under  http:// EC2_Instance_Public_DNS :8080/#/metrics .  The  Collected Metrics  tab displays the load generator and its load engines on the left.     The load generator,  Megaload 1.0.1  aggregates the counters from all the load engines, displaying metrics such as the number of scenarios or sucessful requests for the whole system. Click the name to display the drop-down menu with the full list of available metrics. For example, select  global_counter_scenarios  and check the concurrent users. The next images shows a custom deployment with two load engines.     Below the load generator are all the load engines that have been deployed. Select one of them to display the drop-down menu containing counters and histograms. For example, select  Counters and Gauges  and check the concurrent users for that node.     Histograms  provide information about response times, connection times or requests per second on each of the individual load engines. All these measurements and their units are described in detail in the  Counters  section.", 
            "title": "Real-time metrics"
        }, 
        {
            "location": "/use_dashboards/", 
            "text": "Getting to know the Megaload UI\n\n\nTo access Megaload browser-based user interface, go to \nhttp://\nEC2_Instance_Public_DNS\n:8080/megaload/index.html\n.\n\n\nMegaload has two dashboards, one for \nmanaging and running load tests\n, and one for \nmonitoring and viewing metrics\n. To switch between them, click the menu item on the right:\n\n\n\n  \n\n    \n\n      \n\n      Load testing\n      \n\n    \n\n      \n\n        \nView the load generators and information about the load engines\n\n        \nLoad test: upload, edit and run test cases; view the load report\n\n        \nProperty-based testing: upload and run properties, and view live results\n\n      \n\n    \n\n  \n\n  \n\n    \n\n      \n\n      Monitoring\n      \n\n    \n\n    \n\n      \n\n        \nView metrics, including counters and histograms\n\n        \nView and manage notifications and logs\n\n        \n\n      \n\n    \n\n  \n\n\n\n\n\nLoad testing dashboard\n\n\nThe primary navigation bar provides three main menus, \nLoad generators\n, \nLoad test\n, and \nProperty-based testing\n.\n\n\nLoad generators\n\n\nThe \nLoad generators\n page shows the Megaload instances that have been deployed. In the following example there is one Megaload generator, \nMegaload 1.0.1\n, which consists of one load engine (Megaload node).\n\n\n\n\nLoad test\n\n\nThe Load test page provides all the functionality required to upload and run tests.\n\n\n\n\nUpload test cases\n: Upload test specifications and any additional data. Additional data might be a CSV file that contains usernames and passwords to connect to a specific HTTP server.\n\n\nEdit test cases\n: A JSON test editor that does basic syntactic checks to help you write test specifications.\n\n\nEscript test\n: Upload Escript test specifications.\n\n\nRunner\n: Start and stop tests.\n\n\nLoad report\n: A summary of the test being executed. There are six sections: Status, Assertions, Assertion details, Response time, Rate, and Statistics.\n\n\n\n\n\n\n\nMonitoring\n\n\nTo leave the load testing dashboard and go to the monitoring dashboard, click \nMonitoring\n on the right.\n\n\nMonitoring dashboard\n\n\nOverview page\n\n\nWhen you open Monitoring you see an overview page, which you can customise by adding panels that show metrics, histograms, alarms, or node statistics. See \nlink\n.\n\n\nMetrics\n\n\nYou can view aggregated metrics for the load generator, or metrics for each individual load engine.\n\n\n\n\nCollected metrics\n: View counters and system usage for the load generator, and counters and histograms for each of the load engines.\n\n\n\nLive metrics\n: View counters and system usage in real time.\n\n\n\n\nNotifications\n\n\nView log entries from the different load engines. The logs are provided by two different components: \nerror_logger\n and \nlager\n. You can filter by application, search in logs, and change the log level for individual load engines.\n\n\nNotifications are useful for troubleshooting purposes, but do not provide information about sucessful load tests. \n\n\n\n\n\nLoad testing\n\n\nTo leave the monitoring dashboard and go to the load testing dashboard, click \nLoad testing\n on the right.", 
            "title": "The Megaload UI"
        }, 
        {
            "location": "/use_dashboards/#getting-to-know-the-megaload-ui", 
            "text": "To access Megaload browser-based user interface, go to  http:// EC2_Instance_Public_DNS :8080/megaload/index.html .  Megaload has two dashboards, one for  managing and running load tests , and one for  monitoring and viewing metrics . To switch between them, click the menu item on the right:  \n   \n     \n       \n      Load testing\n       \n     \n       \n         View the load generators and information about the load engines \n         Load test: upload, edit and run test cases; view the load report \n         Property-based testing: upload and run properties, and view live results \n       \n     \n   \n   \n     \n       \n      Monitoring\n       \n     \n     \n       \n         View metrics, including counters and histograms \n         View and manage notifications and logs", 
            "title": "Getting to know the Megaload UI"
        }, 
        {
            "location": "/use_dashboards/#load-testing-dashboard", 
            "text": "The primary navigation bar provides three main menus,  Load generators ,  Load test , and  Property-based testing .  Load generators  The  Load generators  page shows the Megaload instances that have been deployed. In the following example there is one Megaload generator,  Megaload 1.0.1 , which consists of one load engine (Megaload node).   Load test  The Load test page provides all the functionality required to upload and run tests.   Upload test cases : Upload test specifications and any additional data. Additional data might be a CSV file that contains usernames and passwords to connect to a specific HTTP server.  Edit test cases : A JSON test editor that does basic syntactic checks to help you write test specifications.  Escript test : Upload Escript test specifications.  Runner : Start and stop tests.  Load report : A summary of the test being executed. There are six sections: Status, Assertions, Assertion details, Response time, Rate, and Statistics.    Monitoring  To leave the load testing dashboard and go to the monitoring dashboard, click  Monitoring  on the right.", 
            "title": "Load testing dashboard"
        }, 
        {
            "location": "/use_dashboards/#monitoring-dashboard", 
            "text": "Overview page  When you open Monitoring you see an overview page, which you can customise by adding panels that show metrics, histograms, alarms, or node statistics. See  link .  Metrics  You can view aggregated metrics for the load generator, or metrics for each individual load engine.   Collected metrics : View counters and system usage for the load generator, and counters and histograms for each of the load engines.  Live metrics : View counters and system usage in real time.   Notifications  View log entries from the different load engines. The logs are provided by two different components:  error_logger  and  lager . You can filter by application, search in logs, and change the log level for individual load engines.  Notifications are useful for troubleshooting purposes, but do not provide information about sucessful load tests.    Load testing  To leave the monitoring dashboard and go to the load testing dashboard, click  Load testing  on the right.", 
            "title": "Monitoring dashboard"
        }, 
        {
            "location": "/use_load_testing/", 
            "text": "Load testing with Megaload\n\n\nThe \nLoad test\n page provides all the functionality required to upload, edit and run tests, and to view test results.\n\n\nLoading a JSON test\n\n\nUse the \nUpload test cases\n tab to upload the test specification and any additional data. Additional data might be a CSV file that contains usernames and passwords to connect to a specific HTTP server.\n\n\nTo upload a test specification:\n\n\n\n\nClick \nUpload test cases\n.\n\n\nClick the load generator on the left. This shows the upload controls on the right.\n\n\nClick \nAdd files\n and select the files to upload.\n\n\nClick \nStart upload\n or \nStart\n to upload the individual files.\n\n   The status shows as \nUploaded\n or, if the test specification is invalid, \nError\n. If an error occurs, a pop-up window will show the reason.\n\n\n\n\n\n\nYou can split the test specification into separate files and upload them independently. For example, you can upload the test, phases, and scenarios as separate files. Only the contents are stored in Megaload, not the files themselves. When you download or edit the test specification, you'll note that everything becomes a single JSON list.\n\n\nAfter uploading tests, you can view and edit the test specification in the \nJSON editor\n.\n\n\nAditional data\n\n\nAny other data required to execute the test, as a CSV file containing some test parameters, can be uploaded with the \nUpload additional data\n option. These data files will be sent to all load engines in Megaload's load generator. If the option \nUnique IDs\n is selected, the file is split by rows between all the engines in the generator.\n\n\nA use case for the \nUnique IDs\n option is a list of unique user-password pairs that cannot be duplicated between engines. These user-password pairs can be stored in a CSV file, which is then split between engines with this option. For example, in a 4-engine generator with a 1000-lines CSV file, each block of 250 lines will be uploaded to a different engine.\n\n\nEditing, uploading, and clearing tests\n\n\nThe \nEdit test cases\n tab provides a JSON test editor that does basic syntactic checks to help you write test specifications. From here, you can also do the following:\n\n\n\n\nUpload\n tests or test objects to test specification for the load generator\n\n\nDownload\n the full test specification currently loaded for the load generator\n\n\nClear\n the test specification for the load generator\n\n\n\n\nTo view the editor, first select the Megaload generator on the left. This will show the editor on the right, containing the test specification that is currently loaded.\n\n\n\n\n\n\nNote that using the editor is not obligatory. You can write your tests in any text editor of your choice, and then \nupload\n the files directly to Megaload. If you need to do further editing, you can \nopen\n your files in the editor and make changes there.\n\n\nYou can also edit and upload the objects that make up a Megaload test specification.\n\n\nOpening a test\n\n\nTo open an existing JSON test from disk, click \nOpen\n in the editor toolbar, and then select the file. Note that the editor will only accept files that contain valid JSON.\n\n\nMaking changes to tests\n\n\nThe JSON editor features syntax highlighting, automatic indentation, and other tools for editing JSON. You can view the text as code or as a tree with expandable and collapsable nodes. Switch between these modes using the dropdown button in the toolbar.\n\n\nNote:\n If you leave the page after making changes in the editor, you will lose those changes. You can \nsave\n the contents of the editor to disk, or \nupload\n the contents to add them to the test specification for the load generator. The changes you make in the editor will have no effect until you upload the test.\n\n\n\nAlso note the following:\n\n\n\n\nYou cannot \nremove\n objects, but elements and their values can be updated.\n\n\nIf you change an object's \nID\n, this will result in a new object with that ID being added; the existing object will remain in place. References to the object's ID should be changed, if necessary.\n\n\n\n\nSaving your test\n\n\nTo save the contents of the editor to your local disk, click \nSave\n in the editor toolbar. Note that this only saves the contents of the editor; the full test specification that is loaded in the load generator may be different. Saving doesn't change the currently loaded test specification.\n\n\nIf you opened a file from disk, it will be saved with its original filename, otherwise it will be downloaded as \ndocument.json\n.\n\n\nUploading tests from the editor\n\n\nTo add the test in the editor to the current test specification for the load generator, click \nUpload\n in the editor toolbar. This will add the objects in the editor to the specification, or update objects that are already loaded where applicable.\n\n\nNote that this action won't \nreplace\n the currently loaded test specification, but only add or update objects. See the notes under \nMaking changes to tests\n for more information.\n\n\nDownloading the test specification\n\n\nTo download the full list of JSON specifications currently uploaded in the system as a single list of JSON objects, click \nDownload\n in the editor toolbar. The file will be downloaded as \nmegaload-\ntimestamp\n.json\n.\n\n\n\n\n\nClearing tests from Megaload\n\n\nYou can clear the current test specification from the load generator. In the editor toolbar, click \nClear\n, and then click \nOK\n.\n\n\nLoading an Escript test\n\n\nUse the \nEscript test\n tab to upload an Escript test specification. Each uploaded Escript is given an unique identifier in the system that is shown in the user interface after the upload. You can also download all Escript files stored in Megaload from this page.\n\n\n\n\nRunning a test\n\n\nThe \nRunner\n tab provides the controls to start and stop a test.\n\n\nTo run a test:\n\n\n\n\nClick the load generator on the left. This shows the \nTest control\n menu on the right.\n\n\nSelect the test identifier from the drop-down list next to the \nStart\n button.\n\n\nClick \nStart\n.\n\n\n\n\nThe following screenshot shows a test that has been started:\n\n\n\n\nTo stop a test that is running, click the \nStop\n button on the same page.\n\n\nViewing test results\n\n\nThe \nLoad report\n tab provides a summary of the test being executed. The \nLoad report\n consists of six tabs with additional information:\n\n\n\n\n\n\nStatus\n shows the current status of the test, which can be one of the following: \nRunning\n, \nFinished\n or \nStopped\n. The status \nStopped\n is shown when the user clicks on \nStop\n in the \nRunner\n tab.\n\n\n\n\n\n\n\n\nAssertions\n shows a summary of the test assertions in the selected load engine. Test assertions are checks on certain metrics (as detailed in following chapters) that are performed at the end of each phase or test.  \n\n\n\n\n\n\n\n\nAssertion details\n allows the user to check which assertions passed or failed in each phase or test by selecting them using the drop-down buttons.  \n\n\n\n\n\n\n\n\nResponse time\n shows a statistical report about the response time of the current protocol (selected using the drop-down buttons) in the selected load engine. It provides, among other values, the minimum, maximum, mean, variance, histogram and percentiles. At the bottom of the page, there is a table with the response time per URL requested. The response time per URL is only enabled when the HTTP plugin is configured with \nstats_per_url\n to \ntrue\n. (For more information, see the \nHTTP plugin\n section.)  \n\n\n\n\n\n\n\n\nRate\n shows a statistical report about the rate of requests in the selected load engine. It provides, among other values, minimum, maximum, mean, variance, histogram and percentiles of the requests per second rate.  \n\n\n\n\n\n\n\n\nStatistics\n provides a direct link to the full metrics dashboard, also accessible from the \nMonitoring\n link at the top of the page.", 
            "title": "Load testing"
        }, 
        {
            "location": "/use_load_testing/#load-testing-with-megaload", 
            "text": "The  Load test  page provides all the functionality required to upload, edit and run tests, and to view test results.", 
            "title": "Load testing with Megaload"
        }, 
        {
            "location": "/use_load_testing/#loading-a-json-test", 
            "text": "Use the  Upload test cases  tab to upload the test specification and any additional data. Additional data might be a CSV file that contains usernames and passwords to connect to a specific HTTP server.  To upload a test specification:   Click  Upload test cases .  Click the load generator on the left. This shows the upload controls on the right.  Click  Add files  and select the files to upload.  Click  Start upload  or  Start  to upload the individual files. \n   The status shows as  Uploaded  or, if the test specification is invalid,  Error . If an error occurs, a pop-up window will show the reason.    You can split the test specification into separate files and upload them independently. For example, you can upload the test, phases, and scenarios as separate files. Only the contents are stored in Megaload, not the files themselves. When you download or edit the test specification, you'll note that everything becomes a single JSON list.  After uploading tests, you can view and edit the test specification in the  JSON editor .  Aditional data  Any other data required to execute the test, as a CSV file containing some test parameters, can be uploaded with the  Upload additional data  option. These data files will be sent to all load engines in Megaload's load generator. If the option  Unique IDs  is selected, the file is split by rows between all the engines in the generator.  A use case for the  Unique IDs  option is a list of unique user-password pairs that cannot be duplicated between engines. These user-password pairs can be stored in a CSV file, which is then split between engines with this option. For example, in a 4-engine generator with a 1000-lines CSV file, each block of 250 lines will be uploaded to a different engine.", 
            "title": "Loading a JSON test"
        }, 
        {
            "location": "/use_load_testing/#editing-uploading-and-clearing-tests", 
            "text": "The  Edit test cases  tab provides a JSON test editor that does basic syntactic checks to help you write test specifications. From here, you can also do the following:   Upload  tests or test objects to test specification for the load generator  Download  the full test specification currently loaded for the load generator  Clear  the test specification for the load generator   To view the editor, first select the Megaload generator on the left. This will show the editor on the right, containing the test specification that is currently loaded.    Note that using the editor is not obligatory. You can write your tests in any text editor of your choice, and then  upload  the files directly to Megaload. If you need to do further editing, you can  open  your files in the editor and make changes there.  You can also edit and upload the objects that make up a Megaload test specification.  Opening a test  To open an existing JSON test from disk, click  Open  in the editor toolbar, and then select the file. Note that the editor will only accept files that contain valid JSON.  Making changes to tests  The JSON editor features syntax highlighting, automatic indentation, and other tools for editing JSON. You can view the text as code or as a tree with expandable and collapsable nodes. Switch between these modes using the dropdown button in the toolbar.  Note:  If you leave the page after making changes in the editor, you will lose those changes. You can  save  the contents of the editor to disk, or  upload  the contents to add them to the test specification for the load generator. The changes you make in the editor will have no effect until you upload the test.  \nAlso note the following:   You cannot  remove  objects, but elements and their values can be updated.  If you change an object's  ID , this will result in a new object with that ID being added; the existing object will remain in place. References to the object's ID should be changed, if necessary.   Saving your test  To save the contents of the editor to your local disk, click  Save  in the editor toolbar. Note that this only saves the contents of the editor; the full test specification that is loaded in the load generator may be different. Saving doesn't change the currently loaded test specification.  If you opened a file from disk, it will be saved with its original filename, otherwise it will be downloaded as  document.json .  Uploading tests from the editor  To add the test in the editor to the current test specification for the load generator, click  Upload  in the editor toolbar. This will add the objects in the editor to the specification, or update objects that are already loaded where applicable.  Note that this action won't  replace  the currently loaded test specification, but only add or update objects. See the notes under  Making changes to tests  for more information.  Downloading the test specification  To download the full list of JSON specifications currently uploaded in the system as a single list of JSON objects, click  Download  in the editor toolbar. The file will be downloaded as  megaload- timestamp .json .   Clearing tests from Megaload  You can clear the current test specification from the load generator. In the editor toolbar, click  Clear , and then click  OK .", 
            "title": "Editing, uploading, and clearing tests"
        }, 
        {
            "location": "/use_load_testing/#loading-an-escript-test", 
            "text": "Use the  Escript test  tab to upload an Escript test specification. Each uploaded Escript is given an unique identifier in the system that is shown in the user interface after the upload. You can also download all Escript files stored in Megaload from this page.", 
            "title": "Loading an Escript test"
        }, 
        {
            "location": "/use_load_testing/#running-a-test", 
            "text": "The  Runner  tab provides the controls to start and stop a test.  To run a test:   Click the load generator on the left. This shows the  Test control  menu on the right.  Select the test identifier from the drop-down list next to the  Start  button.  Click  Start .   The following screenshot shows a test that has been started:   To stop a test that is running, click the  Stop  button on the same page.", 
            "title": "Running a test"
        }, 
        {
            "location": "/use_load_testing/#viewing-test-results", 
            "text": "The  Load report  tab provides a summary of the test being executed. The  Load report  consists of six tabs with additional information:    Status  shows the current status of the test, which can be one of the following:  Running ,  Finished  or  Stopped . The status  Stopped  is shown when the user clicks on  Stop  in the  Runner  tab.     Assertions  shows a summary of the test assertions in the selected load engine. Test assertions are checks on certain metrics (as detailed in following chapters) that are performed at the end of each phase or test.       Assertion details  allows the user to check which assertions passed or failed in each phase or test by selecting them using the drop-down buttons.       Response time  shows a statistical report about the response time of the current protocol (selected using the drop-down buttons) in the selected load engine. It provides, among other values, the minimum, maximum, mean, variance, histogram and percentiles. At the bottom of the page, there is a table with the response time per URL requested. The response time per URL is only enabled when the HTTP plugin is configured with  stats_per_url  to  true . (For more information, see the  HTTP plugin  section.)       Rate  shows a statistical report about the rate of requests in the selected load engine. It provides, among other values, minimum, maximum, mean, variance, histogram and percentiles of the requests per second rate.       Statistics  provides a direct link to the full metrics dashboard, also accessible from the  Monitoring  link at the top of the page.", 
            "title": "Viewing test results"
        }, 
        {
            "location": "/use_monitoring/", 
            "text": "Monitoring the load generators and tests\n\n\nThe \nMonitoring\n dashboard provides all the real-time metrics under \nhttp://\nEC2_Instance_Public_DNS\n:8080/#/metrics\n. You can also view \nlog entries\n and get an \noverview\n of important metrics.\n\n\nReal-time metrics\n\n\nTo view metrics, click \nMetrics\n in the top menu bar. The \nCollected Metrics\n tab displays the load generator and its load engines on the left.  \n\n\n\n\n\n\n\n\nThe load generator, \nMegaload 1.0.1\n aggregates the counters from all the load engines, displaying metrics such as the number of scenarios or sucessful requests for the whole system. Click the name to display the drop-down menu with the full list of available metrics. For example, select \nglobal_counter_scenarios\n and check the concurrent users. The next images shows a custom deployment with two load engines.\n\n\n\n\n\n\n\n\n\n\nBelow the load generator are all the load engines that have been deployed. Select one of them to display the drop-down menu containing counters and histograms. For example, select \nCounters and Gauges\n and check the concurrent scenarios for that node.\n\n\n\n\n\n\n\n\n\n\nHistograms\n provide information about response times, connection times or requests per second on each of the individual load engines. All these measurements and their units are described in detail in the \nCounters\n section.\n\n\n\n\n\n\n\n\nNotifications\n\n\nView log entries from the different load engines. The logs are provided by two different components: \nerror_logger\n and \nlager\n. You can filter by application, search in logs, and change the log level for individual load engines.\n\n\nNotifications are useful for troubleshooting purposes, but do not provide information about sucessful load tests. \n\n\n\n\nOverview page\n\n\nWhen you open \nMonitoring\n you see an overview page, which you can customise by adding panels that show metrics or histograms. You can also reorganise the page by dragging the panels to different positions.\n\n\n\n\nViewing the overview page\n\n\nTo go to the overview page, click \nMegaload\n on the left in the menu bar.\n\n\nAdding a panel\n\n\n\n\nClick \nadmin\n in the upper right corner, and then select \nProfile management\n.\n\n\nUnder \nDashboard preferences\n, click \nAdd panels\n.\n\n\nOn the \nConfigure panel\n form, select the \nOverview panel type\n and \nNode family\n, and then select or fill in the corresponding options that are shown.\n\n\nClick \nCreate overview panel\n.\n\n\n\n\nEditing, resizing, or removing a panel\n\n\n\n\nClick \nadmin\n in the upper right corner, and then select \nProfile management\n.\n\n\nUnder \nDashboard preferences\n, click on a panel\u2019s title bar to show a set of controls, and choose the appropriate option:\n\n\n\n\n\n    \n\n        \n\n        \nChange the panel\u2019s configuration (opens \nConfigure panel\n)\n\n    \n\n    \n\n        \n\n        \nIncrease the panel's width\n\n    \n\n    \n\n        \n\n        \nDecrease the panel's width\n\n    \n\n    \n\n        \n\n        \nRemove the panel\n\n    \n\n\n\n\n\nResetting the overview page\n\n\nTo remove your customisations, click \nadmin\n in the upper right corner, and then select \nClear dashboard cache\n.", 
            "title": "Monitoring"
        }, 
        {
            "location": "/use_monitoring/#monitoring-the-load-generators-and-tests", 
            "text": "The  Monitoring  dashboard provides all the real-time metrics under  http:// EC2_Instance_Public_DNS :8080/#/metrics . You can also view  log entries  and get an  overview  of important metrics.", 
            "title": "Monitoring the load generators and tests"
        }, 
        {
            "location": "/use_monitoring/#real-time-metrics", 
            "text": "To view metrics, click  Metrics  in the top menu bar. The  Collected Metrics  tab displays the load generator and its load engines on the left.       The load generator,  Megaload 1.0.1  aggregates the counters from all the load engines, displaying metrics such as the number of scenarios or sucessful requests for the whole system. Click the name to display the drop-down menu with the full list of available metrics. For example, select  global_counter_scenarios  and check the concurrent users. The next images shows a custom deployment with two load engines.      Below the load generator are all the load engines that have been deployed. Select one of them to display the drop-down menu containing counters and histograms. For example, select  Counters and Gauges  and check the concurrent scenarios for that node.      Histograms  provide information about response times, connection times or requests per second on each of the individual load engines. All these measurements and their units are described in detail in the  Counters  section.", 
            "title": "Real-time metrics"
        }, 
        {
            "location": "/use_monitoring/#notifications", 
            "text": "View log entries from the different load engines. The logs are provided by two different components:  error_logger  and  lager . You can filter by application, search in logs, and change the log level for individual load engines.  Notifications are useful for troubleshooting purposes, but do not provide information about sucessful load tests.", 
            "title": "Notifications"
        }, 
        {
            "location": "/use_monitoring/#overview-page", 
            "text": "When you open  Monitoring  you see an overview page, which you can customise by adding panels that show metrics or histograms. You can also reorganise the page by dragging the panels to different positions.   Viewing the overview page  To go to the overview page, click  Megaload  on the left in the menu bar.  Adding a panel   Click  admin  in the upper right corner, and then select  Profile management .  Under  Dashboard preferences , click  Add panels .  On the  Configure panel  form, select the  Overview panel type  and  Node family , and then select or fill in the corresponding options that are shown.  Click  Create overview panel .   Editing, resizing, or removing a panel   Click  admin  in the upper right corner, and then select  Profile management .  Under  Dashboard preferences , click on a panel\u2019s title bar to show a set of controls, and choose the appropriate option:   \n     \n         \n         Change the panel\u2019s configuration (opens  Configure panel ) \n     \n     \n         \n         Increase the panel's width \n     \n     \n         \n         Decrease the panel's width \n     \n     \n         \n         Remove the panel \n       Resetting the overview page  To remove your customisations, click  admin  in the upper right corner, and then select  Clear dashboard cache .", 
            "title": "Overview page"
        }, 
        {
            "location": "/test_write/", 
            "text": "Writing a Megaload test\n\n\nThere are two basic concepts in Megaload that define a load profile: the \ntest\n and \nphase\n. A test can be described as a container of phases, and it is the root element which includes all other elements of the load test specification.\n\n\n\n\nEach test contains a sequence of phases that will be executed in that sequence order. A phase is a description of the load profile defined in terms of rate and number of concurrent scenarios (or users simulated by the test). A phase will have a duration and arrival rate, which determines how fast new scenarios are started. Once the maximum number of concurrent scenarios has been reached, it will keep stable while trying to reach the expected rate.\n\n\n\n\nEach phase may contain several \nscenarios\n, which will be executed in parallel during the load test. A scenario contains a sequence of \nactions\n which represent requests to the SUT or additional behaviour.\n\n\nThe rest of this chapter explains how to write a very simple test specification using these concepts. The \nspec\n section describes in detail all the elements of a test specification.\n\n\nThe following example shows you how to write a test for a small online shop that uses HTTP and JSON. The test uses the calls to list customers and to get a customer's details.\n\n\nThe following call lists the customers:\n\n\nGET http://\nIP\n:5050/customers\n\n\n\n\nResponse:\n\n\n{\ndata\n : [ \n           {\nid\n : \ngoku\n, \n           \nemail\n : \ngoku@dragon.ball\n, \n           \naccount_balance\n : 500, \n           \ncurrency\n : \nGBP\n \n           }, \n           {...}, \n           {...} \n          ], \n    \ncount\n : 4 \n} \n\n\n\n\nThe following call gets the details for a specific customer:\n\n\nGET http://\nIP\n:5050/customer/bulma\n\n\n\n\nResponse:\n\n\n{\nid\n : \nbulma\n, \n   \nemail\n : \nbulma@dragon.ball\n, \n   \naccount_balance\n : 750000, \n   \ncurrency\n : \nGBP\n \n} \n\n\n\n\nYou can write the test specification in any text editor, or using the embedded editor on the Megaload dashboard. To use the embedded editor, go to the dashboard, click \nLoad Test\n and then \nEdit test cases\n.\n\n\nStep 1: Define a plugin\n\n\nThe plugin is the target server or system under test (SUT). A plugin looks as follows:\n\n\n{ \n  \nplugin\n : \n    { \n      \nid\n : \nID\n, \n      \nplugin_info\n : \nSPECIFIC_PLUGIN_INFO\n \n    } \n} \n\n\n\n\n\n\nid\n specifies a name for the plugin.\n\n\nplugin_info\n contains the plugin details.\n\n\n\n\nFor Example:\n\n\n{ \n  \nplugin\n : \n    { \n      \nid\n : \nSUT-server\n, \n      \nplugin_info\n : {\nhttp-plugin\n : \n                             {\nservers\n : \n                                 [ \n                                   { \nhost\n : \n127.0.0.1\n, \n                                     \nport\n : 80, \n                                     \nssl\n : false } \n                                 ], \n                               \nstats_per_url\n : true \n                             } \n                    } \n    } \n} \n\n\n\n\nStep 2: Define a scenario\n\n\nOur example has a simple scenario with a single request. A scenario looks as follows:\n\n\n{ \n  \nscenario\n : \n    { \n      \nid\n : \nID\n, \n      \nkeepalive\n : \nREUSE_CONNECTION\n,\n      \nactions\n : \nACTIONS\n\n    } \n} \n\n\n\n\n\n\nid\n is he name you give the scenario.\n\n\nkeepalive\n specifies whether to repeate the scenario and reuse open connections.\n\n\nactions\n will contain the actions that should be executed - in this example an HTTP request.\n\n\n\n\nAn HTTP request looks as follows:\n\n\n{ \n  \nhttp-request\n : \n    { \n      \nplugin_id\n : \nPLUGIN_ID\n, \n      \nmethod\n : \nHTTP_REQUEST_METHOD\n, \n      \npath\n : \nHTTP_REQUEST_URI\n\n    }\n} \n\n\n\n\nFor our example test:\n\n\n{ \n  \nhttp-request\n : \n    { \n      \nplugin_id\n : \nSUT-server\n, \n      \nmethod\n : \nGET\n, \n      \npath\n : \n/customers\n \n    } \n}\n\n\n\n\nThe complete scenario:\n\n\n{ \n  \nscenario\n : \n  { \n    \nid\n : \nget-customers\n, \n    \nkeepalive\n : true, \n    \nactions\n : [{\nhttp-request\n : \n                    { \n                      \nplugin_id\n: \nSUT-server\n, \n                      \nmethod\n: \nGET\n, \n                      path\n: \n/customers\n \n                    } \n                }], \n  } \n} \n\n\n\n\nStep 3: Define a phase\n\n\nA phase includes a load profile that specifies a ramp-up time (so that the system is not immediately overloaded) and the maximum rate and number of processes. It also specifies which scenarios to execute.\n\n\n{ \n  \nphase\n : \n    { \n      \nid\n : \nID\n, \n      \narrival_rate\n : \nRAMP_UP_ARRIVAL_RATE\n,\n      \nduration\n : \nTEST_DURATION\n, \n      \nconcurrent_scenarios\n : \nMAX_CONCURRENT_SCENARIOS\n, \n      \nrate\n : \nRATE\n, \n      \nscenarios\n : \nSCENARIOS\n \n    } \n} \n\n\n\n\n\n\nid\n is the name you give the phase.\n\n\narrival_rate\n specifies an arrival rate in number of scenarios started per second.\n\n\nduration\n specifies the duration of the phase in milliseconds.\n\n\nconcurrent_scenarios\n specifies the maximum number of concurrent scenarios.\n\n\nrate\n specifies the maximum number of requests per second.\n\n\nscenarios\n is used for specifying which scenarios to run and the frequency to choose them. In this example, we will run the scenario from the previous step.\n\n\n\n\nThe complete phase for this example:\n\n\n{ \n  \nphase\n : \n    { \n      \nid\n : \nSUT-low\n, \n      \narrival_rate\n : 10,\n      \nduration\n : 60000,\n      \nconcurrent_scenarios\n : 100,\n      \nrate\n : 250,\n      \nscenarios\n : [{\nget-customers\n : 1}]\n    } \n} \n\n\n\n\nStep 4: Define a test\n\n\nA test is a container of phases. It looks as follows:\n\n\n{ \n  \ntest\n : \n  { \n    \nid\n : \nID\n, \n    \nphases\n : \nPHASES\n, \n    \nplugins\n : \nPLUGINS\n \n  } \n}\n\n\n\n\n\n\nid\n is the name you give the test.\n\n\nphases\n will specify which phases to run. In this example, we will run the phase from the previous step.\n\n\nplugins\n specifies the plugin to use.\n\n\n\n\nStep 5: Put together a valid JSON document\n\n\nMegaload input is a \nlist\n of JSON objects:\n\n\n[ \n  {\ntest\n : ... }, \n  {\nplugin\n : ... }, \n  {\nphase\n : ... }, \n  {\nscenario\n : ... } \n] \n\n\n\n\nYou can now save the test (for example, as \nSUT-test-example.json\n), upload the text file using the Megaload dashboard and run the test. However it would be useful to include some \nchecks\n in the test, using Megaload \nassertions\n.\n\n\nAssertions\n\n\nMegaload assertions can be included in both \ntest\n and \nphase\n specifications. These assertions can check the value of any counter in the system and match it against the provided specification. Assertions are explained in more detail in the section \nassertions\n.\n\n\n{ \n  \ntest\n : \n    { \n      \nid\n : \nSUT-test\n, \n      \nphases\n : [\nSUT-low\n], \n      \nplugins\n : [\nSUT-server\n], \n      \nassertions\n : \nASSERTIONS\n \n    } \n} \n\n\n\n\nThe assertions can include counters and histograms, as shown below.\n\n\n[ \n  {\nassert-counter\n : \n    {\nid\n : \nglobal_counter_failedRequests\n, \n      \nmetric\n : \ncount\n, \n      \nfilter\n : {\neq\n : 0}} \n  }, \n  {\nassert-histogram\n : \n    {\nid\n : \nhttp_histogram_responseTime\n, \n      \nstatistic\n : \nmean\n, \n      \nfilter\n : {\nlt\n : 150000}} \n  } \n]\n\n\n\n\nWhen you run the test, you can view the results of the assertions on the \nLoad report\n page.\n\n\nThere is a different kind of assertion that can be used to validate the response code and content of HTTP responses. These assertions are used to determine whether a request is successful or not and increase the related counter. Thus, the test and phase assertions can be combined with these HTTP assertions to validate the result of a test. \n\n\nAssertions are included in the HTTP request with the following format:\n\n\n{ \n  \nhttp-request\n : \n    { \n      \nplugin_id\n : \nPLUGIN_ID\n, \n      \nmethod\n : \nHTTP_REQUEST_METHOD\n, \n      \npath\n : \nHTTP_REQUEST_URI\n, \n      \nassert_status\n : \nHTTP_RESPONSE_STATUS_CODE\n, \n      \nassert_body\n : \nACTION_CHECK\n \n    } \n} \n\n\n\n\nTo validate the \nresponse code\n:\n\n\n{ \n  \nhttp-request\n : \n    { \n      \nplugin_id\n : \nSUT-server\n, \n      \nmethod\n : \nGET\n, \n      \npath\n : \n/customers\n, \n      \nassert_status\n : \n200\n \n    } \n} \n\n\n\n\nTo validate the \ncontent\n:\n\n\n{ \n  \nhttp-request\n : \n    { \n      \nplugin_id\n : \nSUT-server\n, \n      \nmethod\n : \nGET\n, \n      \npath\n : \n/customers\n, \n      \nassert_body\n :\n          {\njsonpath-value\n : \n              {\npath\n : \nbody.count\n, \n                \nvalue\n : 5}}\n    }\n} \n\n\n\n\nMegaload automatically updates counters for successful and failed requests:\n\n\n\n\nglobal_counter_successfulRequests\n\n\nglobal_counter_failedRequests\n\n\nhttp_counter_successfulRequests_\nSUT_IP\n\n\nhttp_counter_failedRequests_\nSUT_IP\n\n\n\n\nThe following checks whether a user is a customer of the shop:\n\n\n{ \n  \nhttp-request\n : \n    { \n      \nplugin_id\n : \nSUT-server\n, \n      \nmethod\n : \nGET\n, \n      \npath\n : \n/customer/jack\n,\n      \nassert_status\n : \n404\n \n    }\n} \n\n\n\n\nWhen you run the test, go to \nLoad report\n \n \nAssertion details\n on the dashboard to view the results.", 
            "title": "Writing a Megaload test"
        }, 
        {
            "location": "/test_write/#writing-a-megaload-test", 
            "text": "There are two basic concepts in Megaload that define a load profile: the  test  and  phase . A test can be described as a container of phases, and it is the root element which includes all other elements of the load test specification.   Each test contains a sequence of phases that will be executed in that sequence order. A phase is a description of the load profile defined in terms of rate and number of concurrent scenarios (or users simulated by the test). A phase will have a duration and arrival rate, which determines how fast new scenarios are started. Once the maximum number of concurrent scenarios has been reached, it will keep stable while trying to reach the expected rate.   Each phase may contain several  scenarios , which will be executed in parallel during the load test. A scenario contains a sequence of  actions  which represent requests to the SUT or additional behaviour.  The rest of this chapter explains how to write a very simple test specification using these concepts. The  spec  section describes in detail all the elements of a test specification.  The following example shows you how to write a test for a small online shop that uses HTTP and JSON. The test uses the calls to list customers and to get a customer's details.  The following call lists the customers:  GET http:// IP :5050/customers  Response:  { data  : [ \n           { id  :  goku , \n            email  :  goku@dragon.ball , \n            account_balance  : 500, \n            currency  :  GBP  \n           }, \n           {...}, \n           {...} \n          ], \n     count  : 4 \n}   The following call gets the details for a specific customer:  GET http:// IP :5050/customer/bulma  Response:  { id  :  bulma , \n    email  :  bulma@dragon.ball , \n    account_balance  : 750000, \n    currency  :  GBP  \n}   You can write the test specification in any text editor, or using the embedded editor on the Megaload dashboard. To use the embedded editor, go to the dashboard, click  Load Test  and then  Edit test cases .", 
            "title": "Writing a Megaload test"
        }, 
        {
            "location": "/test_write/#step-1-define-a-plugin", 
            "text": "The plugin is the target server or system under test (SUT). A plugin looks as follows:  { \n   plugin  : \n    { \n       id  :  ID , \n       plugin_info  :  SPECIFIC_PLUGIN_INFO  \n    } \n}    id  specifies a name for the plugin.  plugin_info  contains the plugin details.   For Example:  { \n   plugin  : \n    { \n       id  :  SUT-server , \n       plugin_info  : { http-plugin  : \n                             { servers  : \n                                 [ \n                                   {  host  :  127.0.0.1 , \n                                      port  : 80, \n                                      ssl  : false } \n                                 ], \n                                stats_per_url  : true \n                             } \n                    } \n    } \n}", 
            "title": "Step 1: Define a plugin"
        }, 
        {
            "location": "/test_write/#step-2-define-a-scenario", 
            "text": "Our example has a simple scenario with a single request. A scenario looks as follows:  { \n   scenario  : \n    { \n       id  :  ID , \n       keepalive  :  REUSE_CONNECTION ,\n       actions  :  ACTIONS \n    } \n}    id  is he name you give the scenario.  keepalive  specifies whether to repeate the scenario and reuse open connections.  actions  will contain the actions that should be executed - in this example an HTTP request.   An HTTP request looks as follows:  { \n   http-request  : \n    { \n       plugin_id  :  PLUGIN_ID , \n       method  :  HTTP_REQUEST_METHOD , \n       path  :  HTTP_REQUEST_URI \n    }\n}   For our example test:  { \n   http-request  : \n    { \n       plugin_id  :  SUT-server , \n       method  :  GET , \n       path  :  /customers  \n    } \n}  The complete scenario:  { \n   scenario  : \n  { \n     id  :  get-customers , \n     keepalive  : true, \n     actions  : [{ http-request  : \n                    { \n                       plugin_id :  SUT-server , \n                       method :  GET , \n                      path :  /customers  \n                    } \n                }], \n  } \n}", 
            "title": "Step 2: Define a scenario"
        }, 
        {
            "location": "/test_write/#step-3-define-a-phase", 
            "text": "A phase includes a load profile that specifies a ramp-up time (so that the system is not immediately overloaded) and the maximum rate and number of processes. It also specifies which scenarios to execute.  { \n   phase  : \n    { \n       id  :  ID , \n       arrival_rate  :  RAMP_UP_ARRIVAL_RATE ,\n       duration  :  TEST_DURATION , \n       concurrent_scenarios  :  MAX_CONCURRENT_SCENARIOS , \n       rate  :  RATE , \n       scenarios  :  SCENARIOS  \n    } \n}    id  is the name you give the phase.  arrival_rate  specifies an arrival rate in number of scenarios started per second.  duration  specifies the duration of the phase in milliseconds.  concurrent_scenarios  specifies the maximum number of concurrent scenarios.  rate  specifies the maximum number of requests per second.  scenarios  is used for specifying which scenarios to run and the frequency to choose them. In this example, we will run the scenario from the previous step.   The complete phase for this example:  { \n   phase  : \n    { \n       id  :  SUT-low , \n       arrival_rate  : 10,\n       duration  : 60000,\n       concurrent_scenarios  : 100,\n       rate  : 250,\n       scenarios  : [{ get-customers  : 1}]\n    } \n}", 
            "title": "Step 3: Define a phase"
        }, 
        {
            "location": "/test_write/#step-4-define-a-test", 
            "text": "A test is a container of phases. It looks as follows:  { \n   test  : \n  { \n     id  :  ID , \n     phases  :  PHASES , \n     plugins  :  PLUGINS  \n  } \n}   id  is the name you give the test.  phases  will specify which phases to run. In this example, we will run the phase from the previous step.  plugins  specifies the plugin to use.", 
            "title": "Step 4: Define a test"
        }, 
        {
            "location": "/test_write/#step-5-put-together-a-valid-json-document", 
            "text": "Megaload input is a  list  of JSON objects:  [ \n  { test  : ... }, \n  { plugin  : ... }, \n  { phase  : ... }, \n  { scenario  : ... } \n]   You can now save the test (for example, as  SUT-test-example.json ), upload the text file using the Megaload dashboard and run the test. However it would be useful to include some  checks  in the test, using Megaload  assertions .", 
            "title": "Step 5: Put together a valid JSON document"
        }, 
        {
            "location": "/test_write/#assertions", 
            "text": "Megaload assertions can be included in both  test  and  phase  specifications. These assertions can check the value of any counter in the system and match it against the provided specification. Assertions are explained in more detail in the section  assertions .  { \n   test  : \n    { \n       id  :  SUT-test , \n       phases  : [ SUT-low ], \n       plugins  : [ SUT-server ], \n       assertions  :  ASSERTIONS  \n    } \n}   The assertions can include counters and histograms, as shown below.  [ \n  { assert-counter  : \n    { id  :  global_counter_failedRequests , \n       metric  :  count , \n       filter  : { eq  : 0}} \n  }, \n  { assert-histogram  : \n    { id  :  http_histogram_responseTime , \n       statistic  :  mean , \n       filter  : { lt  : 150000}} \n  } \n]  When you run the test, you can view the results of the assertions on the  Load report  page.  There is a different kind of assertion that can be used to validate the response code and content of HTTP responses. These assertions are used to determine whether a request is successful or not and increase the related counter. Thus, the test and phase assertions can be combined with these HTTP assertions to validate the result of a test.   Assertions are included in the HTTP request with the following format:  { \n   http-request  : \n    { \n       plugin_id  :  PLUGIN_ID , \n       method  :  HTTP_REQUEST_METHOD , \n       path  :  HTTP_REQUEST_URI , \n       assert_status  :  HTTP_RESPONSE_STATUS_CODE , \n       assert_body  :  ACTION_CHECK  \n    } \n}   To validate the  response code :  { \n   http-request  : \n    { \n       plugin_id  :  SUT-server , \n       method  :  GET , \n       path  :  /customers , \n       assert_status  :  200  \n    } \n}   To validate the  content :  { \n   http-request  : \n    { \n       plugin_id  :  SUT-server , \n       method  :  GET , \n       path  :  /customers , \n       assert_body  :\n          { jsonpath-value  : \n              { path  :  body.count , \n                 value  : 5}}\n    }\n}   Megaload automatically updates counters for successful and failed requests:   global_counter_successfulRequests  global_counter_failedRequests  http_counter_successfulRequests_ SUT_IP  http_counter_failedRequests_ SUT_IP   The following checks whether a user is a customer of the shop:  { \n   http-request  : \n    { \n       plugin_id  :  SUT-server , \n       method  :  GET , \n       path  :  /customer/jack ,\n       assert_status  :  404  \n    }\n}   When you run the test, go to  Load report     Assertion details  on the dashboard to view the results.", 
            "title": "Assertions"
        }, 
        {
            "location": "/test_spec/", 
            "text": "Test specification\n\n\nThis chapter describes the JSON test specification supported by Megaload. Objects describing the test, phases, scenarios and plugins can be uploaded in separate files. The system will validate that all required configuration is present when starting the load test. \n\n\n\n\n\nTest\n\n\nThe \ntest\n object contains the major elements of a Megaload test.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nUnique test identifier.\n\n\n\n\n\n\nphases\n\n\nne\n-list of strings\n\n\nYes\n\n\nNo\n\n\nList of phase identifiers. These phases must be loaded in the system before starting the test.\n\n\n\n\n\n\nplugins\n\n\nlist of strings\n\n\nYes\n\n\nNo\n\n\nList of plugin identifiers. All plugins used during the test must be listed here.\n\n\n\n\n\n\nglobal_options\n\n\nne-list of global options\n\n\nNo\n\n\nNo\n\n\nGlobal test options that can be retrieved internally by any action through all the test. Each option is a JSON object with a single pair key-value. The value must be a basic JSON type: boolean, number or string.\n\n\n\n\n\n\nassertions\n\n\nne-list of assertion objects\n\n\nNo\n\n\nNo\n\n\nAssertions to check that results match test expectations.\n\n\n\n\n\n\n\n\nNon-empty\n\n\nExample\n\n\n{\ntest\n : {\n            \nid\n : \ntest\n,\n            \nglobal_options\n : [{\noption1\n : \nabc\n},\n                                {\noption2\n : 4567}]\n            \nphases\n : [\nphaseOne\n],\n            \nplugins\n : [\nmy_web_server\n]\n          }\n}\n\n\n\n\n\n\n\nPlugin\n\n\nThe \nplugin\n object defines the target server or system under test.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nUnique plugin identifier.\n\n\n\n\n\n\nplugin_info\n\n\nobject\n\n\nYes\n\n\nNo\n\n\nPlugin specification. See \nProtocols\n.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nplugin\n : {\n              \nid\n : \nmy_web_server\n,\n              \nplugin_info\n : { \nhttp-plugin\n : {\n                                                  \nhost\n : \n192.165.0.1\n,\n                                                  \nport\n : 5050,\n                                                  \nssl\n : false\n                                                }\n                              }\n            }\n}\n\n\n\n\nPhase\n\n\n\n\nThe \nphase\n object describes how test scenarios will be executed. A test can contain multiple phases.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nUnique phase identifier.\n\n\n\n\n\n\narrival_rate\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nThe number of new worker processes (users) started per second. At the beginning of the phase or scenario, workers processes are started gradually, to avoid a call burst.\n\n\n\n\n\n\nduration\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nThe total duration of the phase in milliseconds. Scenarios that are not completed in the predefined time are allowed to finish while the new phase starts. This can result in functional scenarios overlapping between phases, but the rate will be controlled by the new phase parameters.\n\n\n\n\n\n\nconcurrent_scenarios\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nThe maximum number of worker processes (concurrent users) that can run in parallel per instance.\n\n\n\n\n\n\nrate\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nThe target rate of requests per second that the system must reach.\n\n\n\n\n\n\nkeepalive\n\n\nboolean\n\n\nNo\n\n\nNo\n\n\nIndicates whether a user must be kept alive between phases. A value of \u2018true\u2019 will keep those users running and all the established connections open. If the value is \u2018false\u2019, all users will terminate between phases.\n\n\n\n\n\n\nscenarios\n\n\nne-list of objects\n\n\nYes\n\n\nNo\n\n\nA list of the scenarios that must run in this phase with their relative frequency. Frequency is used to randomly choose between scenarios. Each scenario object has a pair \n{scenario : frequency}\n\n\n\n\n\n\nassertions\n\n\nne-list of assertion objects\n\n\nNo\n\n\nNo\n\n\nAssertions to check that results match phase expectations. For more information, see \nAssertions\n.\n\n\n\n\n\n\n\n\nFrequency\n\n\n\n\n\nIn a test specification, a phase consists of one or more scenarios. These scenarios are run in parallel by worker processes until the limit of processes declared in \nconcurrent_scenarios\n is reached (see \nPhase\n). It is not possible to know in advance how many worker processes will be started. There are several reasons for this: the test duration might be too short to reach the \nconcurrent_scenarios\n limit; the scenarios might not be set to \nkeepalive\n, so that a new worker is started once a scenario is finished; or a scenario could be aborted, necessitating a new worker. However, the number of scenarios of each kind that is executed can be defined through the property \nfrequency\n. When a new worker process is about to start, it uses the \nfrequency\n parameter to make its choice following the random weighted choice algorithm. In this algorithm, the phases with a heavier frequency will be chosen more often.\n\n\n\n\nGet all scenarios declared on the current phase \ud835\udc46\n\ud835\udc56\n\u00a0.\u00a0.\u00a0.\u00a0\ud835\udc46\n\ud835\udc57\n\n\nCreate an array with the cumulative frequencies: \ud835\udc34\ud835\udc50\ud835\udc50 = [\ud835\udc39\n\ud835\udc56\n, \ud835\udc39\n\ud835\udc56\n + \ud835\udc39\n\ud835\udc56+1\n,\u00a0.\u00a0.\u00a0.\u00a0\n\ud835\udc39\n\ud835\udc56\n\u202f]\n\n\nGenerate a random number in \ud835\udfe2 \u00b7 \u00b7 \u00b7 \n\ud835\udc39\n\ud835\udc56\n\n\nSelect the position \ud835\udc56 where \ud835\udc34\ud835\udc50\ud835\udc50[\ud835\udc56] \n= \ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc51\ud835\udc5c\ud835\udc5a and \ud835\udc34\ud835\udc50\ud835\udc50[\ud835\udc56-\ud835\udfe3] \n \ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc51\ud835\udc5c\ud835\udc5a\n\n\nThe selected scenario is \ud835\udc46\n\ud835\udc56\n.\n\n\n\n\nFor this algorithm to work, \nfrequency\n must be a positive integer greater than 0. There is no requirement for frequencies to sum up to any amount. In the case of compound scenarios (scenarios which contain a list of components), the frequencies of the components are discarded and the frequency of the compound scenario is the one selected for the algorithm.\n\n\nExample\n\n\n{\nphase\n : {\n             \nid\n : \nphaseOne\n,\n             \narrival_rate\n : 10,\n             \nduration\n : 3000,\n             \nconcurrent_scenarios\n : 5,\n             \nrate\n : 5000,\n             \nscenarios\n : [{\nscenarioOne\n : 1}]\n           }\n}\n\n\n\n\nScenario\n\n\nThe \nscenario\n object contains the actions that comprise a test. Note that actions and components are mutually exclusive: one or the other must be present.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nUnique scenario identifier.\n\n\n\n\n\n\nkeepalive\n\n\nboolean\n\n\nNo\n\n\nNo\n\n\nIndicates whether a user must be kept alive between scenario executions. A value of \u2018true\u2019 will keep those processes running and all the established connections opened; the \ninit\n section will be executed only once, when the connection is established. If the value is \u2018false\u2019, user instances will be terminated each time the scenario is executed and the connection reopened.\n\n\n\n\n\n\nactions\n\n\nne-list of objects\n\n\nYes\n\n\nNo\n\n\nList of actions that will be executed in sequence in this scenario. See \nActions\n.\n\n\n\n\n\n\ncomponents\n\n\nne-list of strings\n\n\nYes\n\n\nNo\n\n\nList of scenario IDs. You can compose complex scenarios from simple ones, by appending the list of actions to those scenarios.\n\n\n\n\n\n\ninit\n\n\nne-list of strings\n\n\nNo\n\n\nNo\n\n\nList of scenario IDs. An init scenario is a special scenario; it cannot contain more init scenarios. These init scenarios, if any, are executed in sequential order and only once before any other action of the scenario.\n\n\n\n\n\n\nteardown\n\n\nne-list of strings\n\n\nNo\n\n\nNo\n\n\nList of scenario IDs. These scenarios are executed in sequential order after every scenario has completed, unless the scenario has keepalive flag set to true. They are also executed at the end of a phase regardless of the keepalive flag.\n\n\n\n\n\n\n\n\nInit\n\n\nThe init scenarios are executed once at the beginning of the scenario execution. If the scenario is tagged as \nkeepalive\n, the init scenario is not repeated with the scenario.\n\n\n\n\n\n\nAny variable stored or state changed during the execution of the init scenario is available during the execution of the main scenario actions. The init scenario can be disrupted in the change of phase; Megaload does not wait for it to be finished before changing the phase.\n\n\nA basic scenario contains a list of actions that are executed in sequential order. Additionally, Megaload allows the user to generate more complex scenarios by using composition.\n\n\nThere may be an arbitrary number of init scenarios within each scenario, which are executed in sequential order.\n\n\nComponents\n\n\n\n\n\nA compound scenario does not contain \nactions\n but \ncomponents\n. The parameter \ncomponents\n is a list of scenario identifiers which actions are called in sequencial order in place of \nactions\n. All the parameters of the component scenarios, such as \nkeepalive\n or \ninit\n, are ignored during the test execution and only the parameters of the compound scenario are used. When the compound scenario has \nkeepalive\n set to \ntrue\n, the whole sequence of actions is repeated until the phase ends. \n\n\n\n\n\n\nExample\n\n\n{\nscenario\n : {\n                \nid\n : \nscenario\n,\n                \ninit\n : [\ninit-scenario-1\n, \ninit-scenario-2\n],\n                \nactions\n : [ {\nhttp-request\n : {\n                                                  \nplugin_id\n : \nlocalhost\n,\n                                                  \nmethod\n : \nGET\n,\n                                                  \npath\n : \n/charges\n,\n                                                  \nheaders\n : {},\n                                                  \nbody\n : []\n                                                }\n                              }\n                            ]\n              }\n}", 
            "title": "Test specification"
        }, 
        {
            "location": "/test_spec/#test-specification", 
            "text": "This chapter describes the JSON test specification supported by Megaload. Objects describing the test, phases, scenarios and plugins can be uploaded in separate files. The system will validate that all required configuration is present when starting the load test.", 
            "title": "Test specification"
        }, 
        {
            "location": "/test_spec/#test", 
            "text": "The  test  object contains the major elements of a Megaload test.     Name  Type  Required  Action  Info      id  string  Yes  No  Unique test identifier.    phases  ne -list of strings  Yes  No  List of phase identifiers. These phases must be loaded in the system before starting the test.    plugins  list of strings  Yes  No  List of plugin identifiers. All plugins used during the test must be listed here.    global_options  ne-list of global options  No  No  Global test options that can be retrieved internally by any action through all the test. Each option is a JSON object with a single pair key-value. The value must be a basic JSON type: boolean, number or string.    assertions  ne-list of assertion objects  No  No  Assertions to check that results match test expectations.     Non-empty  Example  { test  : {\n             id  :  test ,\n             global_options  : [{ option1  :  abc },\n                                { option2  : 4567}]\n             phases  : [ phaseOne ],\n             plugins  : [ my_web_server ]\n          }\n}", 
            "title": "Test"
        }, 
        {
            "location": "/test_spec/#plugin", 
            "text": "The  plugin  object defines the target server or system under test.     Name  Type  Required  Action  Info      id  string  Yes  No  Unique plugin identifier.    plugin_info  object  Yes  No  Plugin specification. See  Protocols .     Example  { plugin  : {\n               id  :  my_web_server ,\n               plugin_info  : {  http-plugin  : {\n                                                   host  :  192.165.0.1 ,\n                                                   port  : 5050,\n                                                   ssl  : false\n                                                }\n                              }\n            }\n}", 
            "title": "Plugin"
        }, 
        {
            "location": "/test_spec/#phase", 
            "text": "The  phase  object describes how test scenarios will be executed. A test can contain multiple phases.     Name  Type  Required  Action  Info      id  string  Yes  No  Unique phase identifier.    arrival_rate  integer  Yes  No  The number of new worker processes (users) started per second. At the beginning of the phase or scenario, workers processes are started gradually, to avoid a call burst.    duration  integer  Yes  No  The total duration of the phase in milliseconds. Scenarios that are not completed in the predefined time are allowed to finish while the new phase starts. This can result in functional scenarios overlapping between phases, but the rate will be controlled by the new phase parameters.    concurrent_scenarios  integer  Yes  No  The maximum number of worker processes (concurrent users) that can run in parallel per instance.    rate  integer  Yes  No  The target rate of requests per second that the system must reach.    keepalive  boolean  No  No  Indicates whether a user must be kept alive between phases. A value of \u2018true\u2019 will keep those users running and all the established connections open. If the value is \u2018false\u2019, all users will terminate between phases.    scenarios  ne-list of objects  Yes  No  A list of the scenarios that must run in this phase with their relative frequency. Frequency is used to randomly choose between scenarios. Each scenario object has a pair  {scenario : frequency}    assertions  ne-list of assertion objects  No  No  Assertions to check that results match phase expectations. For more information, see  Assertions .     Frequency   In a test specification, a phase consists of one or more scenarios. These scenarios are run in parallel by worker processes until the limit of processes declared in  concurrent_scenarios  is reached (see  Phase ). It is not possible to know in advance how many worker processes will be started. There are several reasons for this: the test duration might be too short to reach the  concurrent_scenarios  limit; the scenarios might not be set to  keepalive , so that a new worker is started once a scenario is finished; or a scenario could be aborted, necessitating a new worker. However, the number of scenarios of each kind that is executed can be defined through the property  frequency . When a new worker process is about to start, it uses the  frequency  parameter to make its choice following the random weighted choice algorithm. In this algorithm, the phases with a heavier frequency will be chosen more often.   Get all scenarios declared on the current phase \ud835\udc46 \ud835\udc56 \u00a0.\u00a0.\u00a0.\u00a0\ud835\udc46 \ud835\udc57  Create an array with the cumulative frequencies: \ud835\udc34\ud835\udc50\ud835\udc50 = [\ud835\udc39 \ud835\udc56 , \ud835\udc39 \ud835\udc56  + \ud835\udc39 \ud835\udc56+1 ,\u00a0.\u00a0.\u00a0.\u00a0 \ud835\udc39 \ud835\udc56 \u202f]  Generate a random number in \ud835\udfe2 \u00b7 \u00b7 \u00b7  \ud835\udc39 \ud835\udc56  Select the position \ud835\udc56 where \ud835\udc34\ud835\udc50\ud835\udc50[\ud835\udc56]  = \ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc51\ud835\udc5c\ud835\udc5a and \ud835\udc34\ud835\udc50\ud835\udc50[\ud835\udc56-\ud835\udfe3]   \ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc51\ud835\udc5c\ud835\udc5a  The selected scenario is \ud835\udc46 \ud835\udc56 .   For this algorithm to work,  frequency  must be a positive integer greater than 0. There is no requirement for frequencies to sum up to any amount. In the case of compound scenarios (scenarios which contain a list of components), the frequencies of the components are discarded and the frequency of the compound scenario is the one selected for the algorithm.  Example  { phase  : {\n              id  :  phaseOne ,\n              arrival_rate  : 10,\n              duration  : 3000,\n              concurrent_scenarios  : 5,\n              rate  : 5000,\n              scenarios  : [{ scenarioOne  : 1}]\n           }\n}", 
            "title": "Phase"
        }, 
        {
            "location": "/test_spec/#scenario", 
            "text": "The  scenario  object contains the actions that comprise a test. Note that actions and components are mutually exclusive: one or the other must be present.     Name  Type  Required  Action  Info      id  string  Yes  No  Unique scenario identifier.    keepalive  boolean  No  No  Indicates whether a user must be kept alive between scenario executions. A value of \u2018true\u2019 will keep those processes running and all the established connections opened; the  init  section will be executed only once, when the connection is established. If the value is \u2018false\u2019, user instances will be terminated each time the scenario is executed and the connection reopened.    actions  ne-list of objects  Yes  No  List of actions that will be executed in sequence in this scenario. See  Actions .    components  ne-list of strings  Yes  No  List of scenario IDs. You can compose complex scenarios from simple ones, by appending the list of actions to those scenarios.    init  ne-list of strings  No  No  List of scenario IDs. An init scenario is a special scenario; it cannot contain more init scenarios. These init scenarios, if any, are executed in sequential order and only once before any other action of the scenario.    teardown  ne-list of strings  No  No  List of scenario IDs. These scenarios are executed in sequential order after every scenario has completed, unless the scenario has keepalive flag set to true. They are also executed at the end of a phase regardless of the keepalive flag.     Init  The init scenarios are executed once at the beginning of the scenario execution. If the scenario is tagged as  keepalive , the init scenario is not repeated with the scenario.    Any variable stored or state changed during the execution of the init scenario is available during the execution of the main scenario actions. The init scenario can be disrupted in the change of phase; Megaload does not wait for it to be finished before changing the phase.  A basic scenario contains a list of actions that are executed in sequential order. Additionally, Megaload allows the user to generate more complex scenarios by using composition.  There may be an arbitrary number of init scenarios within each scenario, which are executed in sequential order.  Components   A compound scenario does not contain  actions  but  components . The parameter  components  is a list of scenario identifiers which actions are called in sequencial order in place of  actions . All the parameters of the component scenarios, such as  keepalive  or  init , are ignored during the test execution and only the parameters of the compound scenario are used. When the compound scenario has  keepalive  set to  true , the whole sequence of actions is repeated until the phase ends.     Example  { scenario  : {\n                 id  :  scenario ,\n                 init  : [ init-scenario-1 ,  init-scenario-2 ],\n                 actions  : [ { http-request  : {\n                                                   plugin_id  :  localhost ,\n                                                   method  :  GET ,\n                                                   path  :  /charges ,\n                                                   headers  : {},\n                                                   body  : []\n                                                }\n                              }\n                            ]\n              }\n}", 
            "title": "Scenario"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nHTTP\n\n\n[{\ntest\n : {\nid\n : \npayment-test\n,\n            \nphases\n : [\npayment-phase\n],\n            \nplugins\n : [\npayment-server\n]\n           }},\n\n {\nplugin\n : {\nid\n : \npayment-server\n,\n              \nplugin_info\n \n              : {\nhttp-plugin\n : {\nservers\n : [{\nhost\n : \n10.100.0.120\n,\n                                                \nport\n : 5050,\n                                                \nssl\n : false}\n                                              ]\n                                 }\n                }\n             }\n },\n\n {\nphase\n : {\nid\n : \npayment-phase\n,\n             \narrival_rate\n : 10,\n             \nduration\n : 600000,\n             \nconcurrent_scenarios\n : 250,\n             \nrate\n : 500,\n             \nscenarios\n : [{\npayment-scenario\n : 1}]}},\n\n {\nscenario\n :\n  {\nid\n : \npayment-scenario\n,\n   \nactions\n : [ \n       {\ndata-csv\n : {\nfile\n : \nusers_list.csv\n,\n                      \nname\n : \nall_users\n\n                     }\n       },\n       {\ndata-csv_value\n : {\nname\n : \nall_users\n,\n                            \nfields\n : [1, 2],\n                            \nvars\n : [\nusername\n, \npassword\n]\n                           }\n       },\n       {\nhttp-request\n : {\nplugin_id\n : \npayment-server\n,\n                          \nmethod\n : \nPOST\n,\n                          \npath\n : \n/shop/session\n,\n                          \nbody\n : {\njsonpath-multiset\n :\n                                {\n                                  \nobject\n :\n                                       \n{\\\nusername\\\n: \\\nuser\\\n,\n                                         \\\npassword\\\n: \\\npassword\\\n}\n,\n                                  \npairs\n : [\n                                      {\nvalue\n : {\nvar-get\n : {\nname\n : \nusername\n}},\n                                       \npath\n : \nusername\n},\n                                      {\nvalue\n : {\nvar-get\n : {\nname\n : \npassword\n}},\n                                       \npath\n : \npassword\n}\n                                  ]\n                                }\n                                  }\n                         }\n       },\n       {\njsonpath-get\n : {\npath\n : \nheaders.location\n,\n                          \nvariable\n : \nshoppingSession\n\n                         }\n       },\n       {\nhttp-request\n : {\nplugin_id\n : \npayment-server\n,\n                          \nmethod\n : \nGET\n,\n                          \npath\n : {\nvar-get\n : {\nname\n :\n                                                 \nshoppingSession\n}}\n                         }\n       },\n       {\nhttp-request\n : {\nplugin_id\n : \npayment-server\n,\n                          \nmethod\n : \nGET\n,\n                          \npath\n : {\nurl-join\n :\n                                      { \nroot\n : \n/shop/user\n,\n                                        \npath\n : {\nvar-get\n : {\nname\n : \nusername\n}\n                                                 }\n                                      }\n                                   }\n                         }\n       },\n       {\nhttp-request\n : {\nplugin_id\n : \npayment-server\n,\n                          \nmethod\n : \nPOST\n,\n                          \npath\n : \n/shop/basket/sonyDSCW800compactdigitalcamera\n,\n                          \nbody\n : \n{\\\nprice\\\n: {\\\namount\\\n : 59,\n                                                 \\\ncurrency\\\n: \\\nGBP\\\n}}\n\n                         }\n       },\n       {\njsonpath-get\n : {\npath\n : \nheaders.location\n,\n                          \nvariable\n : \nproductDetails\n\n                         }\n       },\n       {\nhttp-request\n : {\nplugin_id\n : \npayment-server\n,\n                          \nmethod\n : \nGET\n,\n                          \npath\n : {\nvar-get\n : {\nname\n : \nproductDetails\n}}\n                         }\n       },    \n       {\nhttp-request\n : {\nplugin_id\n : \npayment-server\n,\n                          \nmethod\n : \nGET\n,\n                          \npath\n : \n/shop/payment\n\n                         }\n       },\n       {\njsonpath-get\n : {\npath\n : \nbody.payment_methods[0].uri\n,\n                          \nvariable\n : \npaymentMethod\n\n                         }\n       },\n       {\nhttp-request\n : {\nplugin_id\n : \npayment-server\n,\n                          \nmethod\n : \nPOST\n,\n                          \npath\n : {\nvar-get\n : {\nname\n : \npaymentMethod\n}},\n                          \nbody\n : \n{\\\namount\\\n : 59, \\\ncurrency\\\n : \\\nGBP\\\n,\n                                     \\\nsecurity_code\\\n : \\\n123\\\n}\n\n                         }\n       }\n   ]}}\n]\n\n\n\n\nXMPP\n\n\n#!/usr/bin/env escript\n\n%% Adapted from https://github.com/esl/amoc\n\n-include_lib(\nexml/include/exml.hrl\n).\n\n%% ===================================================================\n-define(HOST, \nlocalhost\n). %% The virtual host served by the server\n-define(SERVER_IPS, {\n127.0.0.1\n}). %% Tuple of servers, for example {\n10.100.0.21\n, \n10.100.0.22\n}\n-define(CHECKER_SESSIONS_INDICATOR, 10). %% How often a checker session should be generated\n-define(SLEEP_TIME_AFTER_SCENARIO, 10000). %% wait 10s after scenario before disconnecting\n-define(NUMBER_OF_PREV_NEIGHBOURS, 4).\n-define(NUMBER_OF_NEXT_NEIGHBOURS, 4).\n-define(NUMBER_OF_SEND_MESSAGE_REPEATS, 73).\n-define(SLEEP_TIME_AFTER_EVERY_MESSAGE, 20000).\n\n\n%% ===================================================================\n%% Counters and histograms\n-define(MESSAGES_CT, [\nxmpp\n, \ncounter\n, \nmessages_sent\n]).\n-define(MESSAGE_TTD_H, [\nxmpp\n, \nhistogram\n, \nmessage_ttd\n]).\n-define(CONNECTION_CT, [\nxmpp\n, \ncounter\n, \nconnections\n]).\n-define(CONNECTION_H, [\nxmpp\n, \nhistogram\n, \nconnection\n]).\n-define(CONNECTION_FAILURE_CT, [\nxmpp\n, \ncounter\n, \nconnection_failures\n]).\n\n\n%% ===================================================================\n%% Define initial values.\n%% The regulation will use the load_regulation_targets/2 callback afterwards\n-rate(150).\n-workers(100).\n-arrival_rate(20). %% Number of new scenarios started per second\n%% Set total of unique ids, will be split among nodes\n%% Used to generate the user ids later on. Retrieved from the process\n%% dictionary erlang:get(unique_id).\n-unique_ids(15000).\n%% ===================================================================\n\nmain([]) -\n\n    MyId = erlang:get(unique_id),\n    Cfg = make_user(MyId, \nres1\n),\n\n    IsChecker = MyId rem ?CHECKER_SESSIONS_INDICATOR == 0,\n\n    {ConnectionTime, ConnectionResult} = timer:tc(escalus_connection, start, [Cfg]),\n    Client = case ConnectionResult of\n                 {ok, ConnectedClient, _, _} -\n\n                     loader_metrics:update_counter(?CONNECTION_CT, 1),\n                     loader_metrics:update_histogram(?CONNECTION_H, ConnectionTime),\n                     ConnectedClient;\n                 _Error -\n\n                     loader_metrics:update_counter(?CONNECTION_FAILURE_CT, 1),\n                     throw(abort_scenario)\n             end,\n\n    do(IsChecker, MyId, Client),\n\n    timer:sleep(?SLEEP_TIME_AFTER_SCENARIO),\n    send_presence_unavailable(Client),\n    escalus_connection:stop(Client).\n\n%% This callback may return a list of metrics to regulate the load.\n%% Otherwise, it's also useful to create all XMPP specific metrics.\ninit_load_regulation_metrics() -\n\n    loader_metrics:new_counter(?MESSAGES_CT),\n    loader_metrics:new_histogram(?MESSAGE_TTD_H),\n    loader_metrics:new_counter(?CONNECTION_CT),\n    loader_metrics:new_counter(?CONNECTION_FAILURE_CT),\n    loader_metrics:new_histogram(?CONNECTION_H),\n    {ok, []}.\n\n%% Regulation callback. Megaload will use the number of workers and rate\n%% to set the maximum generated by the system. These could be capped lower\n%% if the machine is not able to cope with the amount of load.\n%% The gauges 'global_gauge_maxRate' and 'global_gauge_maxWorker' will show\n%% this capped limits in the UI.\n%% Megaload automatically regulates the number of workers, however the rate\n%% will depend on the scenario described in the escript. Regulation will\n%% only be triggered by short-lived scenarios.\n%% Nonetheless, this kind of example regulates the rate with its\n%% own timers, so built-in Megaload regulation would not be needed.\nload_regulation_targets(_Metrics,_OldTargets) -\n\n    NewTargets = {{workers, 1500}, {rate, 3000}},\n    {ok, NewTargets}.\n\nuser_spec(ProfileId, Password, Res) -\n    \n    [ {username, ProfileId},\n      {server, ?HOST},\n      {host, pick_server(?SERVER_IPS)},\n      {password, Password},\n      {carbons, false},\n      {stream_management, false},\n      {resource, Res}\n    ].\n\nmake_user(Id, R) -\n\n    BinId = integer_to_binary(Id),\n    ProfileId = \nuser_\n, BinId/binary\n,\n    Password = \npassword_\n, BinId/binary\n,\n    user_spec(ProfileId, Password, R).\n\ndo(false, MyId, Client) -\n\n    escalus_connection:set_filter_predicate(Client, none),\n\n    send_presence_available(Client),\n    timer:sleep(5000),\n\n    NeighbourIds = lists:delete(MyId, lists:seq(max(1,MyId-?NUMBER_OF_PREV_NEIGHBOURS),\n                                                MyId+?NUMBER_OF_NEXT_NEIGHBOURS)),\n    send_messages_many_times(Client, ?SLEEP_TIME_AFTER_EVERY_MESSAGE, NeighbourIds);\ndo(_Other, _MyId, Client) -\n\n    send_presence_available(Client),\n    receive_forever(Client).\n\nreceive_forever(Client) -\n\n    Stanza = escalus_connection:get_stanza(Client, message, infinity),\n    Now = from_now(os:timestamp()),\n    case Stanza of\n        #xmlel{name = \nmessage\n, attrs=Attrs} -\n\n            case lists:keyfind(\ntimestamp\n, 1, Attrs) of\n                {_, Sent} -\n\n                    TTD = (Now - binary_to_integer(Sent)),\n                    loader_metrics:update_histogram(?MESSAGE_TTD_H, TTD);\n                _ -\n\n                    ok\n            end;\n        _ -\n\n            ok\n    end,\n    receive_forever(Client).\n\n\nsend_presence_available(Client) -\n\n    Pres = escalus_stanza:presence(\navailable\n),\n    escalus_connection:send(Client, Pres).\n\nsend_presence_unavailable(Client) -\n\n    Pres = escalus_stanza:presence(\nunavailable\n),\n    escalus_connection:send(Client, Pres).\n\nsend_messages_many_times(Client, MessageInterval, NeighbourIds) -\n\n    S = fun(_) -\n\n                send_messages_to_neighbors(Client, NeighbourIds, MessageInterval)\n        end,\n    lists:foreach(S, lists:seq(1, ?NUMBER_OF_SEND_MESSAGE_REPEATS)).\n\n\nsend_messages_to_neighbors(Client, TargetIds, SleepTime) -\n\n    [send_message(Client, make_jid(TargetId), SleepTime)\n     || TargetId \n- TargetIds].\n\nsend_message(Client, ToId, SleepTime) -\n\n    MsgIn = make_message(ToId),\n    TimeStamp = integer_to_binary(from_now(os:timestamp())),\n    escalus_connection:send(Client, escalus_stanza:setattr(MsgIn, \ntimestamp\n, TimeStamp)),\n    loader_metrics:update_counter(?MESSAGES_CT, 1),\n    %% Increases counters of total, successful requests and histograms of\n    %% requests per second. \n    loader_requests:inc_successful(),\n    timer:sleep(SleepTime).\n\nmake_message(ToId) -\n\n    Body = \nhello sir, you are a gentelman and a scholar.\n,\n    Id = escalus_stanza:id(),\n    escalus_stanza:set_id(escalus_stanza:chat_to(ToId, Body), Id).\n\nmake_jid(Id) -\n\n    BinInt = integer_to_binary(Id),\n    ProfileId = \nuser_\n, BinInt/binary\n,\n    Host = ?HOST,\n    \n ProfileId/binary, \n@\n, Host/binary \n.\n\npick_server(Servers) -\n\n    S = size(Servers),\n    N = erlang:phash2(self(), S) + 1,\n    element(N, Servers).\n\nfrom_now({MegaSecs,Secs,Usecs}) -\n\n    (MegaSecs * 1000000 + Secs) * 1000000 + Usecs.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#http", 
            "text": "[{ test  : { id  :  payment-test ,\n             phases  : [ payment-phase ],\n             plugins  : [ payment-server ]\n           }},\n\n { plugin  : { id  :  payment-server ,\n               plugin_info  \n              : { http-plugin  : { servers  : [{ host  :  10.100.0.120 ,\n                                                 port  : 5050,\n                                                 ssl  : false}\n                                              ]\n                                 }\n                }\n             }\n },\n\n { phase  : { id  :  payment-phase ,\n              arrival_rate  : 10,\n              duration  : 600000,\n              concurrent_scenarios  : 250,\n              rate  : 500,\n              scenarios  : [{ payment-scenario  : 1}]}},\n\n { scenario  :\n  { id  :  payment-scenario ,\n    actions  : [ \n       { data-csv  : { file  :  users_list.csv ,\n                       name  :  all_users \n                     }\n       },\n       { data-csv_value  : { name  :  all_users ,\n                             fields  : [1, 2],\n                             vars  : [ username ,  password ]\n                           }\n       },\n       { http-request  : { plugin_id  :  payment-server ,\n                           method  :  POST ,\n                           path  :  /shop/session ,\n                           body  : { jsonpath-multiset  :\n                                {\n                                   object  :\n                                        {\\ username\\ : \\ user\\ ,\n                                         \\ password\\ : \\ password\\ } ,\n                                   pairs  : [\n                                      { value  : { var-get  : { name  :  username }},\n                                        path  :  username },\n                                      { value  : { var-get  : { name  :  password }},\n                                        path  :  password }\n                                  ]\n                                }\n                                  }\n                         }\n       },\n       { jsonpath-get  : { path  :  headers.location ,\n                           variable  :  shoppingSession \n                         }\n       },\n       { http-request  : { plugin_id  :  payment-server ,\n                           method  :  GET ,\n                           path  : { var-get  : { name  :\n                                                  shoppingSession }}\n                         }\n       },\n       { http-request  : { plugin_id  :  payment-server ,\n                           method  :  GET ,\n                           path  : { url-join  :\n                                      {  root  :  /shop/user ,\n                                         path  : { var-get  : { name  :  username }\n                                                 }\n                                      }\n                                   }\n                         }\n       },\n       { http-request  : { plugin_id  :  payment-server ,\n                           method  :  POST ,\n                           path  :  /shop/basket/sonyDSCW800compactdigitalcamera ,\n                           body  :  {\\ price\\ : {\\ amount\\  : 59,\n                                                 \\ currency\\ : \\ GBP\\ }} \n                         }\n       },\n       { jsonpath-get  : { path  :  headers.location ,\n                           variable  :  productDetails \n                         }\n       },\n       { http-request  : { plugin_id  :  payment-server ,\n                           method  :  GET ,\n                           path  : { var-get  : { name  :  productDetails }}\n                         }\n       },    \n       { http-request  : { plugin_id  :  payment-server ,\n                           method  :  GET ,\n                           path  :  /shop/payment \n                         }\n       },\n       { jsonpath-get  : { path  :  body.payment_methods[0].uri ,\n                           variable  :  paymentMethod \n                         }\n       },\n       { http-request  : { plugin_id  :  payment-server ,\n                           method  :  POST ,\n                           path  : { var-get  : { name  :  paymentMethod }},\n                           body  :  {\\ amount\\  : 59, \\ currency\\  : \\ GBP\\ ,\n                                     \\ security_code\\  : \\ 123\\ } \n                         }\n       }\n   ]}}\n]", 
            "title": "HTTP"
        }, 
        {
            "location": "/examples/#xmpp", 
            "text": "#!/usr/bin/env escript\n\n%% Adapted from https://github.com/esl/amoc\n\n-include_lib( exml/include/exml.hrl ).\n\n%% ===================================================================\n-define(HOST,  localhost ). %% The virtual host served by the server\n-define(SERVER_IPS, { 127.0.0.1 }). %% Tuple of servers, for example { 10.100.0.21 ,  10.100.0.22 }\n-define(CHECKER_SESSIONS_INDICATOR, 10). %% How often a checker session should be generated\n-define(SLEEP_TIME_AFTER_SCENARIO, 10000). %% wait 10s after scenario before disconnecting\n-define(NUMBER_OF_PREV_NEIGHBOURS, 4).\n-define(NUMBER_OF_NEXT_NEIGHBOURS, 4).\n-define(NUMBER_OF_SEND_MESSAGE_REPEATS, 73).\n-define(SLEEP_TIME_AFTER_EVERY_MESSAGE, 20000).\n\n\n%% ===================================================================\n%% Counters and histograms\n-define(MESSAGES_CT, [ xmpp ,  counter ,  messages_sent ]).\n-define(MESSAGE_TTD_H, [ xmpp ,  histogram ,  message_ttd ]).\n-define(CONNECTION_CT, [ xmpp ,  counter ,  connections ]).\n-define(CONNECTION_H, [ xmpp ,  histogram ,  connection ]).\n-define(CONNECTION_FAILURE_CT, [ xmpp ,  counter ,  connection_failures ]).\n\n\n%% ===================================================================\n%% Define initial values.\n%% The regulation will use the load_regulation_targets/2 callback afterwards\n-rate(150).\n-workers(100).\n-arrival_rate(20). %% Number of new scenarios started per second\n%% Set total of unique ids, will be split among nodes\n%% Used to generate the user ids later on. Retrieved from the process\n%% dictionary erlang:get(unique_id).\n-unique_ids(15000).\n%% ===================================================================\n\nmain([]) - \n    MyId = erlang:get(unique_id),\n    Cfg = make_user(MyId,  res1 ),\n\n    IsChecker = MyId rem ?CHECKER_SESSIONS_INDICATOR == 0,\n\n    {ConnectionTime, ConnectionResult} = timer:tc(escalus_connection, start, [Cfg]),\n    Client = case ConnectionResult of\n                 {ok, ConnectedClient, _, _} - \n                     loader_metrics:update_counter(?CONNECTION_CT, 1),\n                     loader_metrics:update_histogram(?CONNECTION_H, ConnectionTime),\n                     ConnectedClient;\n                 _Error - \n                     loader_metrics:update_counter(?CONNECTION_FAILURE_CT, 1),\n                     throw(abort_scenario)\n             end,\n\n    do(IsChecker, MyId, Client),\n\n    timer:sleep(?SLEEP_TIME_AFTER_SCENARIO),\n    send_presence_unavailable(Client),\n    escalus_connection:stop(Client).\n\n%% This callback may return a list of metrics to regulate the load.\n%% Otherwise, it's also useful to create all XMPP specific metrics.\ninit_load_regulation_metrics() - \n    loader_metrics:new_counter(?MESSAGES_CT),\n    loader_metrics:new_histogram(?MESSAGE_TTD_H),\n    loader_metrics:new_counter(?CONNECTION_CT),\n    loader_metrics:new_counter(?CONNECTION_FAILURE_CT),\n    loader_metrics:new_histogram(?CONNECTION_H),\n    {ok, []}.\n\n%% Regulation callback. Megaload will use the number of workers and rate\n%% to set the maximum generated by the system. These could be capped lower\n%% if the machine is not able to cope with the amount of load.\n%% The gauges 'global_gauge_maxRate' and 'global_gauge_maxWorker' will show\n%% this capped limits in the UI.\n%% Megaload automatically regulates the number of workers, however the rate\n%% will depend on the scenario described in the escript. Regulation will\n%% only be triggered by short-lived scenarios.\n%% Nonetheless, this kind of example regulates the rate with its\n%% own timers, so built-in Megaload regulation would not be needed.\nload_regulation_targets(_Metrics,_OldTargets) - \n    NewTargets = {{workers, 1500}, {rate, 3000}},\n    {ok, NewTargets}.\n\nuser_spec(ProfileId, Password, Res) -     \n    [ {username, ProfileId},\n      {server, ?HOST},\n      {host, pick_server(?SERVER_IPS)},\n      {password, Password},\n      {carbons, false},\n      {stream_management, false},\n      {resource, Res}\n    ].\n\nmake_user(Id, R) - \n    BinId = integer_to_binary(Id),\n    ProfileId =  user_ , BinId/binary ,\n    Password =  password_ , BinId/binary ,\n    user_spec(ProfileId, Password, R).\n\ndo(false, MyId, Client) - \n    escalus_connection:set_filter_predicate(Client, none),\n\n    send_presence_available(Client),\n    timer:sleep(5000),\n\n    NeighbourIds = lists:delete(MyId, lists:seq(max(1,MyId-?NUMBER_OF_PREV_NEIGHBOURS),\n                                                MyId+?NUMBER_OF_NEXT_NEIGHBOURS)),\n    send_messages_many_times(Client, ?SLEEP_TIME_AFTER_EVERY_MESSAGE, NeighbourIds);\ndo(_Other, _MyId, Client) - \n    send_presence_available(Client),\n    receive_forever(Client).\n\nreceive_forever(Client) - \n    Stanza = escalus_connection:get_stanza(Client, message, infinity),\n    Now = from_now(os:timestamp()),\n    case Stanza of\n        #xmlel{name =  message , attrs=Attrs} - \n            case lists:keyfind( timestamp , 1, Attrs) of\n                {_, Sent} - \n                    TTD = (Now - binary_to_integer(Sent)),\n                    loader_metrics:update_histogram(?MESSAGE_TTD_H, TTD);\n                _ - \n                    ok\n            end;\n        _ - \n            ok\n    end,\n    receive_forever(Client).\n\n\nsend_presence_available(Client) - \n    Pres = escalus_stanza:presence( available ),\n    escalus_connection:send(Client, Pres).\n\nsend_presence_unavailable(Client) - \n    Pres = escalus_stanza:presence( unavailable ),\n    escalus_connection:send(Client, Pres).\n\nsend_messages_many_times(Client, MessageInterval, NeighbourIds) - \n    S = fun(_) - \n                send_messages_to_neighbors(Client, NeighbourIds, MessageInterval)\n        end,\n    lists:foreach(S, lists:seq(1, ?NUMBER_OF_SEND_MESSAGE_REPEATS)).\n\n\nsend_messages_to_neighbors(Client, TargetIds, SleepTime) - \n    [send_message(Client, make_jid(TargetId), SleepTime)\n     || TargetId  - TargetIds].\n\nsend_message(Client, ToId, SleepTime) - \n    MsgIn = make_message(ToId),\n    TimeStamp = integer_to_binary(from_now(os:timestamp())),\n    escalus_connection:send(Client, escalus_stanza:setattr(MsgIn,  timestamp , TimeStamp)),\n    loader_metrics:update_counter(?MESSAGES_CT, 1),\n    %% Increases counters of total, successful requests and histograms of\n    %% requests per second. \n    loader_requests:inc_successful(),\n    timer:sleep(SleepTime).\n\nmake_message(ToId) - \n    Body =  hello sir, you are a gentelman and a scholar. ,\n    Id = escalus_stanza:id(),\n    escalus_stanza:set_id(escalus_stanza:chat_to(ToId, Body), Id).\n\nmake_jid(Id) - \n    BinInt = integer_to_binary(Id),\n    ProfileId =  user_ , BinInt/binary ,\n    Host = ?HOST,\n      ProfileId/binary,  @ , Host/binary  .\n\npick_server(Servers) - \n    S = size(Servers),\n    N = erlang:phash2(self(), S) + 1,\n    element(N, Servers).\n\nfrom_now({MegaSecs,Secs,Usecs}) - \n    (MegaSecs * 1000000 + Secs) * 1000000 + Usecs.", 
            "title": "XMPP"
        }, 
        {
            "location": "/protocols/", 
            "text": "Protocols\n\n\nHTTP\n\n\nPlugin definition\n\n\nThe \nhttp-plugin\n object represents the \nplugin_info\n in a \nplugin\n object.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nservers\n\n\nlist of server objects\n\n\nYes\n\n\nNo\n\n\nServers list; allows IP load balancing.\n\n\n\n\n\n\ntimeout\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTimeout in milliseconds; defaults to 30000;\n\n\n\n\n\n\nconnect_timeout\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nConnection timeout in milliseconds; defaults to 15000;\n\n\n\n\n\n\nstats_per_url\n\n\nboolean\n\n\nNo\n\n\nNo\n\n\nGenerates stats per URL.\n\n\n\n\n\n\n\n\nThe \nserver\n object represents the server information.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nIPv4 or IPv6 address of the HTTP server.\n\n\n\n\n\n\nport\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nPort number of the HTTP server of the SUT.\n\n\n\n\n\n\nssl\n\n\nboolean\n\n\nYes\n\n\nNo\n\n\nSets SSL connection.\n\n\n\n\n\n\n\n\nThe plugin does a round robin between servers to establish connections. Statistics are retrieved per IP. \n\nhost\n accepts the following address representations for IPv4:\n\n\n\n\nDotted decimal: \n192.0.2.235\n\n\nDotted hexadecimal: \n0xC0.0x00.0x02.0xEB\n\n\nHexadecimal: \n0xC00002EB\n\n\nDecimal: \n3221226219\n\n\n\n\nIt accepts the following representations for IPv6:\n\n\n\n\nFull address: \n2001:0db8:0000:0000:0000:ff00:0042:8329\n\n\nShortened address, without leading zeroes: \n2001:db8:0:0:0:ff00:42:8329\n\n\nShortened address, without consecutive sections of zeroes: \n2001:db8::ff00:42:8329\n\n\n\n\nExample\n\n\n{\nhttp-plugin\n : {\nservers\n : [{\nhost\n : \n192.165.0.1\n,\n                                \nport\n : 5050,\n                                \nssl\n : false}\n                              ],\n                  \nstats_per_url\n : true\n                 }\n}\n\n\n\n\nHTTP request\n\n\nThe \nhttp-request\n object performs an HTTP request.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nplugin_id\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nPlugin ID. Must belong to one of the plugins declared in the specification.\n\n\n\n\n\n\nmethod\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nValid HTTP method: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\n\n\n\n\n\n\npath\n\n\nstring\n\n\nYes\n\n\nYes\n\n\nURI of the request as defined in \nhttp://tools.ietf.org/html/rfc2616#section-5.1.2\n. Can be the result of an action.\n\n\n\n\n\n\nheaders\n\n\nobject\n\n\nNo\n\n\nNo\n\n\nJSON object which represents the header list. Each member is a header pair. \n{ header-name : header-value }\n\n\n\n\n\n\nbody\n\n\nstring or list of strings\n\n\nNo\n\n\nYes\n\n\nString or list of strings which are appended to build the body. Can be replaced for the result of an action.\n\n\n\n\n\n\ngroup\n\n\nstring\n\n\nNo\n\n\nNo\n\n\nGroup label used in reporting. For example: response times per group of requests or successful/failed requests per group.\n\n\n\n\n\n\nassert_status\n\n\nstring\n\n\nNo\n\n\nNo\n\n\nAsserts HTTP response status code is that specified. Determines whether a request is successful.\n\n\n\n\n\n\nassert_body\n\n\nobject\n\n\nNo\n\n\nYes\n\n\nAsserts that the body of the response matches the specification provided here. Determines whether a request is successful.\n\n\n\n\n\n\n\n\nIf the evaluation of \npath\n or \nbody\n fails before the request is sent, the request is considered invalid and the scenario aborted. \n\n\nResponse asserted in \nassert_body\n is of the form:\n\n\n{\n      \nbody\n : \nBODY\n,\n      \nstatus\n : \nSTATUS\n,\n      \nreason\n : \nREASON\n,\n      \nheaders\n : \nHEADERS\n\n}\n\n\n\n\nExample\n\n\n{\nhttp-request\n : {\n                    \nplugin_id\n : \nmy_web_server\n,\n                    \nmethod\n : \nPOST\n,\n                    \npath\n : \n/charges\n,\n                    \nheaders\n : {\u201cContent-Type\u201d : \u201capplication/json\u201d},\n                    \nbody\n : \n{ \\\nid\\\n: \\\ncu_228rD6XZsvYmuc\\\n}\n,\n                    \nassert_status\n : \n200\n,\n                    \nassert_body\n :\n                      {\njsonpath-value\n :\n                        {\npath\n : \nbody.count\n,\n                          \nvalue\n : 5}}\n                  }\n}\n\n\n\n\nAssuming the body of the response is something like:\n\n\n{\ncount\n : 2,\n \ndata\n : [ { \nid\n : \nd98fn357fn23\n,\n              \namount\n : 6324,\n              \ncurrency\n : \ngbp\n },\n            { \nid\n : \nd98fn3qwrqr1\n,\n              \namount\n : 50,\n              \ncurrency\n : \ngbp\n }\n          ]\n}\n\n\n\n\nthe request would be counted as failed as the value for \ncount\n is 2 and not 5.\n\n\nThe HTTP client redirects all requests that \nMUST\n be redirected following: \nhttp://tools.ietf.org/html/rfc2616#section-10.3\n. Those redirects are included in the statistics and any other redirection should be handled from the test specification.\n\n\nHTTP requests return a JSON object, which can be queried with the JSON actions. The following table shows the format of the HTTP response:\n\n\nThe \nhttp-response\n object contains the following:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nstatus\n\n\nstring\n\n\nStatus code, represented as a string. See \nhttp://tools.ietf.org/html/rfc2616#section-6.1.1\n.\n\n\n\n\n\n\nreason\n\n\nstring\n\n\nReason phrase. See \nhttp://tools.ietf.org/html/rfc2616#section-6.1.1\n.\n\n\n\n\n\n\nheaders\n\n\nlist of objects\n\n\nResponse headers as a list of objects. Header name is always lowercase.\n\n\n\n\n\n\nbody\n\n\nstring\n\n\nResponse body.\n\n\n\n\n\n\n\n\nExample\n\n\n\n\n\n{\n  \nstatus\n : \n200\n,\n  \nreason\n : \nOK\n,\n  \nheaders\n : [{\nContent-Type\n : \napplication/json\n}], \n  \nbody\n : \n{\\\ncustomer\\\n : { \\\nactive_card\\\n : {\\\ntype\\\n : \\\nVisa\\\n,\n                                                 \\\nexp_month\\\n : 6},\n                              \\\nemail\\\n : \\\nme@me.com\\\n\n                             }\n            }\u201d\n}", 
            "title": "Protocols"
        }, 
        {
            "location": "/protocols/#protocols", 
            "text": "", 
            "title": "Protocols"
        }, 
        {
            "location": "/protocols/#http", 
            "text": "Plugin definition  The  http-plugin  object represents the  plugin_info  in a  plugin  object.     Name  Type  Required  Action  Info      servers  list of server objects  Yes  No  Servers list; allows IP load balancing.    timeout  integer  No  No  Timeout in milliseconds; defaults to 30000;    connect_timeout  integer  No  No  Connection timeout in milliseconds; defaults to 15000;    stats_per_url  boolean  No  No  Generates stats per URL.     The  server  object represents the server information.     Name  Type  Required  Action  Info      host  string  Yes  No  IPv4 or IPv6 address of the HTTP server.    port  integer  Yes  No  Port number of the HTTP server of the SUT.    ssl  boolean  Yes  No  Sets SSL connection.     The plugin does a round robin between servers to establish connections. Statistics are retrieved per IP.  host  accepts the following address representations for IPv4:   Dotted decimal:  192.0.2.235  Dotted hexadecimal:  0xC0.0x00.0x02.0xEB  Hexadecimal:  0xC00002EB  Decimal:  3221226219   It accepts the following representations for IPv6:   Full address:  2001:0db8:0000:0000:0000:ff00:0042:8329  Shortened address, without leading zeroes:  2001:db8:0:0:0:ff00:42:8329  Shortened address, without consecutive sections of zeroes:  2001:db8::ff00:42:8329   Example  { http-plugin  : { servers  : [{ host  :  192.165.0.1 ,\n                                 port  : 5050,\n                                 ssl  : false}\n                              ],\n                   stats_per_url  : true\n                 }\n}  HTTP request  The  http-request  object performs an HTTP request.     Name  Type  Required  Action  Info      plugin_id  string  Yes  No  Plugin ID. Must belong to one of the plugins declared in the specification.    method  string  Yes  No  Valid HTTP method: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT    path  string  Yes  Yes  URI of the request as defined in  http://tools.ietf.org/html/rfc2616#section-5.1.2 . Can be the result of an action.    headers  object  No  No  JSON object which represents the header list. Each member is a header pair.  { header-name : header-value }    body  string or list of strings  No  Yes  String or list of strings which are appended to build the body. Can be replaced for the result of an action.    group  string  No  No  Group label used in reporting. For example: response times per group of requests or successful/failed requests per group.    assert_status  string  No  No  Asserts HTTP response status code is that specified. Determines whether a request is successful.    assert_body  object  No  Yes  Asserts that the body of the response matches the specification provided here. Determines whether a request is successful.     If the evaluation of  path  or  body  fails before the request is sent, the request is considered invalid and the scenario aborted.   Response asserted in  assert_body  is of the form:  {\n       body  :  BODY ,\n       status  :  STATUS ,\n       reason  :  REASON ,\n       headers  :  HEADERS \n}  Example  { http-request  : {\n                     plugin_id  :  my_web_server ,\n                     method  :  POST ,\n                     path  :  /charges ,\n                     headers  : {\u201cContent-Type\u201d : \u201capplication/json\u201d},\n                     body  :  { \\ id\\ : \\ cu_228rD6XZsvYmuc\\ } ,\n                     assert_status  :  200 ,\n                     assert_body  :\n                      { jsonpath-value  :\n                        { path  :  body.count ,\n                           value  : 5}}\n                  }\n}  Assuming the body of the response is something like:  { count  : 2,\n  data  : [ {  id  :  d98fn357fn23 ,\n               amount  : 6324,\n               currency  :  gbp  },\n            {  id  :  d98fn3qwrqr1 ,\n               amount  : 50,\n               currency  :  gbp  }\n          ]\n}  the request would be counted as failed as the value for  count  is 2 and not 5.  The HTTP client redirects all requests that  MUST  be redirected following:  http://tools.ietf.org/html/rfc2616#section-10.3 . Those redirects are included in the statistics and any other redirection should be handled from the test specification.  HTTP requests return a JSON object, which can be queried with the JSON actions. The following table shows the format of the HTTP response:  The  http-response  object contains the following:     Name  Type  Info      status  string  Status code, represented as a string. See  http://tools.ietf.org/html/rfc2616#section-6.1.1 .    reason  string  Reason phrase. See  http://tools.ietf.org/html/rfc2616#section-6.1.1 .    headers  list of objects  Response headers as a list of objects. Header name is always lowercase.    body  string  Response body.     Example   {\n   status  :  200 ,\n   reason  :  OK ,\n   headers  : [{ Content-Type  :  application/json }], \n   body  :  {\\ customer\\  : { \\ active_card\\  : {\\ type\\  : \\ Visa\\ ,\n                                                 \\ exp_month\\  : 6},\n                              \\ email\\  : \\ me@me.com\\ \n                             }\n            }\u201d\n}", 
            "title": "HTTP"
        }, 
        {
            "location": "/actions/", 
            "text": "Actions\n\n\n\n\n\nYou can also use the separate \nActions\n menu.\n\n\nTime\n\n\nCSV handling\n\n\nStatistical counters\n\n\nTest counters\n\n\nGeneric checks\n\n\nLogical operators\n\n\nControl structures\n\n\nVariables\n\n\nURL handling\n\n\nJSON handling\n\n\nString handling\n\n\nMath", 
            "title": "Actions"
        }, 
        {
            "location": "/actions/#actions", 
            "text": "You can also use the separate  Actions  menu.  Time  CSV handling  Statistical counters  Test counters  Generic checks  Logical operators  Control structures  Variables  URL handling  JSON handling  String handling  Math", 
            "title": "Actions"
        }, 
        {
            "location": "/assertions/", 
            "text": "Assertions\n\n\nAssertions are used to check whether test results comply with expectations. they can be included in a test or in a phase specification. Both phase assertion and a test assertion is a list of of \nassert-counter\n and \nassert-histogram\n assertions. All of them must be successful for the test or phase to pass.\n\n\nWhen assertions are included in a test specification, the histograms used are the representation of the specified metric for the whole test. When assertions are included in a phase specification, the histograms used are the representation of the specified metric for that single phase.\n\n\nCounter\n\n\nThe \nassert-counter\n action does a check on the value of the specified counter.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCounter name as described in \nCounters\n.\n\n\n\n\n\n\nmetric\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nTakes the value \npercent\n or \ncount\n. Defines if the assertion is done regarding the counter value or the percentage it represents over the total of requests.\n\n\n\n\n\n\nfilter\n\n\nfilter object\n\n\nYes\n\n\nNo\n\n\nFilter to assert the success of the test. A filter is a single condition. Applied over the choice of \nmetric\n.\n\n\n\n\n\n\n\n\nThe \nfilter\n object can use one of the following conditions:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nlte\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value less than or equal to \nlte\n value.\n\n\n\n\n\n\nlt\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value less than \nlt\n value.\n\n\n\n\n\n\ngte\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value greather than or equal to \ngte\n value.\n\n\n\n\n\n\ngt\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value greather than \ngt\n value.\n\n\n\n\n\n\neq\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value is equal to \neq\n value.\n\n\n\n\n\n\n\\end{tcolorbox}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample\n\n\n{\nassert-counter\n : {\nid\n : \nhttp_counter_responseCode_200_localhost\n,\n                     \nmetric\n : \npercent\n,\n                     \nfilter\n : {\nlte\n : 75}\n                    }\n}\n\n\n\n\nHistogram\n\n\nThe \nassert-histogram\n action does a check on the collection of values in a histogram.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nHistogram name as described in chapter \nCounters\n.\n\n\n\n\n\n\nstatistic\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nDefines the statistic on which to apply the filter. Values in: \nmin\n, \nmax\n, \nmean\n, \nmedian\n, \npercentile50\n, \npercentile75\n, \npercentile90\n, \npercentile95\n, \npercentile99\n, \npercentile999\n.\n\n\n\n\n\n\nfilter\n\n\nfilter object\n\n\nYes\n\n\nNo\n\n\nFilter to assert the success of the test. A filter is a single condition. Applied over the choice of \nstatistic\n.\n\n\n\n\n\n\n\n\nThe \nfilter\n object:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nlte\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value less than or equal to \nlte\n value.\n\n\n\n\n\n\nlt\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value less than \nlt\n value.\n\n\n\n\n\n\ngte\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value greather than or equal to \ngte\n value.\n\n\n\n\n\n\ngt\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value greather than \ngt\n value.\n\n\n\n\n\n\neq\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nCounter value is equal to \neq\n value.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nassert-histogram\n : {\nid\n : \nhttp_counter_responseTime\n,\n                       \nstatistic\n : \nmean\n,\n                       \nfilter\n : {\nlt\n : 3000}\n                    }\n}", 
            "title": "Assertions"
        }, 
        {
            "location": "/assertions/#assertions", 
            "text": "Assertions are used to check whether test results comply with expectations. they can be included in a test or in a phase specification. Both phase assertion and a test assertion is a list of of  assert-counter  and  assert-histogram  assertions. All of them must be successful for the test or phase to pass.  When assertions are included in a test specification, the histograms used are the representation of the specified metric for the whole test. When assertions are included in a phase specification, the histograms used are the representation of the specified metric for that single phase.", 
            "title": "Assertions"
        }, 
        {
            "location": "/assertions/#counter", 
            "text": "The  assert-counter  action does a check on the value of the specified counter.     Name  Type  Required  Action  Info      id  string  Yes  No  Counter name as described in  Counters .    metric  string  Yes  No  Takes the value  percent  or  count . Defines if the assertion is done regarding the counter value or the percentage it represents over the total of requests.    filter  filter object  Yes  No  Filter to assert the success of the test. A filter is a single condition. Applied over the choice of  metric .     The  filter  object can use one of the following conditions:     Name  Type  Required  Action  Info      lte  integer  Yes  No  Counter value less than or equal to  lte  value.    lt  integer  Yes  No  Counter value less than  lt  value.    gte  integer  Yes  No  Counter value greather than or equal to  gte  value.    gt  integer  Yes  No  Counter value greather than  gt  value.    eq  integer  Yes  No  Counter value is equal to  eq  value.    \\end{tcolorbox}         Example  { assert-counter  : { id  :  http_counter_responseCode_200_localhost ,\n                      metric  :  percent ,\n                      filter  : { lte  : 75}\n                    }\n}", 
            "title": "Counter"
        }, 
        {
            "location": "/assertions/#histogram", 
            "text": "The  assert-histogram  action does a check on the collection of values in a histogram.     Name  Type  Required  Action  Info      id  string  Yes  No  Histogram name as described in chapter  Counters .    statistic  string  Yes  No  Defines the statistic on which to apply the filter. Values in:  min ,  max ,  mean ,  median ,  percentile50 ,  percentile75 ,  percentile90 ,  percentile95 ,  percentile99 ,  percentile999 .    filter  filter object  Yes  No  Filter to assert the success of the test. A filter is a single condition. Applied over the choice of  statistic .     The  filter  object:     Name  Type  Required  Action  Info      lte  integer  Yes  No  Counter value less than or equal to  lte  value.    lt  integer  Yes  No  Counter value less than  lt  value.    gte  integer  Yes  No  Counter value greather than or equal to  gte  value.    gt  integer  Yes  No  Counter value greather than  gt  value.    eq  integer  Yes  No  Counter value is equal to  eq  value.     Example  { assert-histogram  : { id  :  http_counter_responseTime ,\n                        statistic  :  mean ,\n                        filter  : { lt  : 3000}\n                    }\n}", 
            "title": "Histogram"
        }, 
        {
            "location": "/counters/", 
            "text": "Counters\n\n\nMegaload retrieves all counters and histograms, displaying them in the real-time web dashboard.\nCounters are also used in test and phase assertions to validate the success of the test. A counter can be used in an assertion as the counter value or as a percentage over the total of requests \nglobal_totalRequests\n.\n\n\nPredefined counters\n\n\nGlobal counters\n\n\nGlobal counters keep track of totals or actuals, including all servers and protocols.\n\n\nglobal_counter_users\n\nThe total running virtual users.\n\nA virtual user is an instance of a plugin, which can have one or several connections to a server. This counter reports the current total; at the end of the test it resets to 0.\n\nNote that each scenario can run several virtual users in parallel, either by starting several plugins or plugins with several connections. Thus, \nglobal_counter_users\n may be larger than \nglobal_counter_scenarios\n.\n\n\n\n\nglobal_counter_scenarios\n\nNumber of concurrent scenarios.\n\n\nglobal_counter_totalRequests\n\nNumber of requests sent since the start of the test.\n\n\nglobal_counter_successfulRequests\n\nNumber of successful requests sent since the start of the test.\n\n\nglobal_counter_failedRequests\n\nNumber of failed requests sent since the start of the test.\n\n\nglobal_counter_invalidRequests\n\nNumber of invalid requests generated since the start of the test. A request is invalid if it fails before being sent, that is, it is not well-formed. Invalid requests do not increase the counters of total or failed requests.\n\n\nglobal_counter_initSections\n\nNumber of init sections executed since the start of the test.\n\n\nglobal_counter_teardownSections\n\nNumber of teardown sections executed since the start of the test.\n\n\nglobal_counter_scenario_\nid\n\nNumber of running scenarios of type \nid\n.\n\n\nglobal_counter_totalScenarios_\nid\n\nNumber of scenarios of type \nid\n executed started since the start of the test.\n\n\nglobal_counter_abortedScenarios\n\nNumber of scenarios which have been aborted since the start of the test.\n\n\nglobal_counter_abortedScenarios_\nid\n\nNumber of scenarios of type \nid\n which have been aborted since the start of the test.\n\n\n\n\nHTTP counters\n\n\n\n\n\nThe following counters are specific to the HTTP protocol.\n\n\nhttp_counter_responseSize\n\nTotal bytes of data received by the HTTP protocol from all servers since the start of the test.\n\n\nhttp_counter_responseCode_\ncode\n_\nhost\n\nNumber of HTTP responses with code \ncode\n from host \nhost\n since the start of the test.\n\n\nhttp_counter_connectionRefused_\nhost\n\nNumber of connections refused by host \nhost\n since the start of the test. These requests are counted in \nglobal_failedRequests\n.\n\n\nhttp_counter_connectionTimeout_\nhost\n\nNumber of connections timeout by host \nhost\n since the start of the test. These requests are counted in \nglobal_failedRequests\n.\n\n\nhttp_counter_connectionError_\nhost\n\nNumber of connections failed with a reason different from timeout or refused by host \nhost\n since the start of the test. These requests are counted in \nglobal_failedRequests\n.\n\n\nhttp_counter_timeoutRequests_\nhost\n\nNumber of requests timed out by host \nhost\n since the start of the test. This counter is the addition of \nhttp_timeoutRequests_\nhost\n_\nuri\n counters, if present. These requests are counted in \nglobal_failedRequests\n.\n\n\nhttp_counter_timeoutRequests_\nhost\n_\nuri\n\n(Optional) Number of requests to URI \nuri\n timed out by host \nhost\n since the start of the test. These requests are counted in \nhttp_timeoutRequests_\nhost\n.\n\nNote: \nuri\n is the request path if the plugin is configured with the option \nstats_per_url\n.\n\n\nhttp_counter_timeoutRequests_\nhost\n_\ngroup\n\n(Optional) Number of requests tagged with the group \ngroup\n and timed out by host \nhost\n since the start of the test. These requests are counted in \nhttp_timeoutRequests_\nhost\n.\n\nNote: \ngroup\n is the parameter \ngroup\n of the request.\n\n\nhttp_counter_successfulRequests_\nhost\n\nNumber of successful requests to host \nhost\n since the start of the test. This counter is the addition of \nhttp_successfulRequests_\nhost\n_\nuri\n counters, if present. These requests are counted in \nglobal_successfulRequests\n.\n\nNote: A request is successful if it returns a syntactically valid HTTP response and its body and status assertions validate to true, in case such assertions exist. Any syntactically valid HTTP response without assertions is considered successful.\n\n\nhttp_counter_successfulRequests_\nhost\n_\nuri\n\n(Optional) Number of successful requests to URI \nuri\n and host \nhost\n since the start of the test. These requests are counted in \nhttp_successfulRequests_\nhost\n.\n\nNote: A request is successful if it returns a syntactically valid HTTP response and its body and status assertions validate to true or are undefined.\n\nNote: \nuri\n is the request path if the plugin is configured with the option \nstats_per_url\n.\n\n\nhttp_counter_successfulRequests_\nhost\n_\ngroup\n\n(Optional) Number of successful requests tagged with the group \ngroup\n to \nhost\n since the start of the test. These requests are counted in \nhttp_successfulRequests_\nhost\n.\n\nNote: A request is successful if it returns a syntactically valid HTTP response and its body and status assertions validate to true or are undefined.\n\nNote: \ngroup\n is the parameter \ngroup\n of the request.\n\n\nhttp_counter_failedRequests_\nhost\n\nNumber of failed requests to host \nhost\n since the start of the test. This counter is the addition of \nhttp_failedRequests_\nhost\n_\nuri\n counters, if present. These requests are counted in \nglobal_failedRequests\n.\n\nNote: A request is failed if it returns a syntactically valid HTTP response and its body or status assertions validate to false, in case such assertions exist.\n\n\nhttp_counter_failedRequests_\nhost\n_\nuri\n\n(Optional) Number of failed requests to URI \nuri\n and host \nhost\n since the start of the test. These requests are counted as \nhttp_failedRequests_\nhost\n.\n\nNote: A request is failed if it returns a syntactically valid HTTP response and its body or status assertions validate to false.\n\nNote: \nuri\n is the request path if the plugin is configured with the option \nstatss_per_url\n. \n\n\nhttp_counter_failedRequests_\nhost\n_\ngroup\n\n(Optional) Number of failed requests tagged with the group \ngroup\n to host \nhost\n since the start of the test. These requests are counted as \nhttp_failedRequests_\nhost\n.\n\nNote: A request is failed if it returns a syntactically valid HTTP response and its body or status assertions validate to false.\n\nNote: \ngroup\n is the parameter \ngroup\n of the request.\n\n\nhttp_counter_errorRequests_\nhost\n\nNumber of error requests to host \nhost\n since the start of the test. These requests are counted in \nglobal_failedRequests\n.\n\nNote: A request is counted as an error if the HTTP response is syntactically invalid or the server connection returns an error different from connection refused or connection timeout.\n\n\nhttp_counter_errorRequests_\nhost\n_\nuri\n\n(Optional) Number of error requests to URI \nuri\n and host \nhost\n since the start of the test. These requests are counted in \nhttp_errorRequests_\nhost\n.\n\nNote: A request is counted as an error if the HTTP response is syntactically invalid or the server connection returns an error different from connection refused or connection timeout.\n\nNote: \nuri\n is the request path if the plugin is configured with the option \nstats_per_url\n.\n\n\nhttp_counter_errorRequests_\nhost\n_\ngroup\n\n(Optional) Number of error requests tagged with the group \ngroup\n from host \nhost\n since the start of the test. These requests are counted in \nhttp_errorRequests_host\n.\n\nNote: A request is counted as an error if the HTTP response is syntactically invalid or the server connection returns an error different from connection refused or connection timeout.\n\nNote: \ngroup\n is the parameter \ngroup\n of the request.\n\n\n\n\nCustom counters\n\n\nCounters defined by the users in the test specification can be used in assertions. It is currently not possible to define user histograms.\n\n\nSee actions \ncounter-new\n, \ncounter-inc\n, \ncounter-value\n.\n\n\ncustom_counter_\ncounter\n\nCustom counter defined in the test specification\n\n\nPredefined gauges\n\n\nThe gauges defined in Megaload provide information about the system itself. They report useful information as the targets for each node or current workload. Sometimes, the test targets may not be meet due to the response of the SUT, but in other cases it will be required to scale up Megaload.\nGauges provide an insight on Megaload itself.\n\n\nGlobal gauges\n\n\nglobal_gauge_maxRate\n\nLive local target rate.\n\nSet based on the target specified in the phase -- if the test is specified as JSON -- or based on the local load regulation mechanism -- if the test is specified as Escript.\n\nSee \nglobal_histogram_requestsPerSecond\n for the local actual rate.\n\n\nglobal_gauge_maxWorkers\n\nLive local target (max) number of workers (scenarios).\n\nSet based on the target specified in the phase -- if the test is specified as JSON -- or based on the local load regulation mechanism -- if the test is specified as Escript.\n\nSee \nglobal_counter_scenarios\n for the local actual number of workers.\n\n\nglobal_gauge_phaseRate\n\nTarget rate from the current phase.\n\n\nglobal_gauge_phaseWorkers\n\nTarget number of workers (scenarios) from the current phase.\n\n\nglobal_gauge_phaseRatePerc\n\nPercentage of the rate specified in the phase that must be fulfilled by the node.\n\n\nglobal_gauge_phaseWorkersPerc\n\nPercentage of the concurrent scenarios specified in the phase that must be fulfilled by the node.\n\n\nSystem monitoring\n\n\n\n\n\nPredefined histograms\n\n\nHistograms provide statistical information about a value: \nmin\n, \nmax\n, \nmean\n, \nmedian\n, \npercentile 50\n, \npercentile 75\n, \npercentile 90\n, \npercentile 95\n, \npercentile 99\n, \npercentile 999\n.\n\n\nThe histograms described in the following subsections report instant values, that is, the histogram for the last 60 seconds. These histograms allow you to monitor very precisely the evolution of the test in execution through the web interface, with the visualization of individual parameters as min, max or means.\n\n\nHistograms are used in phase assertions and test assertions to validate the success of the test.\nIn order to allow these verifications, there are some special histograms for response times and rate of requests, which provide the response time for the whole of the test or phase.\n\nTest and phase histograms are displayed in Megaload-UI, preceded by the tags \ntest_\n or \nphase_\n.\n\n\nGlobal histograms\n\n\n\n\n\n\n\nglobal_histogram_requestsPerSecond\n\nRate of requests per second. Reports the statistics for the last 60 seconds of testing. Includes all servers and protocols.\n\nTest and phase histograms are available as \ntest_global_histogram_requestsPerSecond\n and \nphase_global_histogram_requestsPerSecond\n.\n\n\nglobal_histogram_unsatisfiedRps\n\nP0ercentage of the target rate that is not fulfilled by the node.\n\n\nHTTP histograms\n\n\n\n\n\nhttp_histogram_responseSize_\nhost\n\nBytes of data received per response from host since the start of the test. Reports the statistics for the last 60 seconds of testing.\n\nTest and phase histograms are available as \ntest_http_histogram_responseSize_\nhost\n and \nphase_http_histogram_responseSize_\nhost\n\n\nhttp_counter_responseTime\n\nResponse time in microseconds per request since the start of the test.\n\nTest and phase histograms are available as \ntest_http_histogram_responseTime\n and \nphase_http_histogram_responseTime\n.\n\nThis histogram is the aggregation of \nhttp_responseTime_\nhost\n.\n\n\nhttp_counter_responseTime_\nhost\n\nResponse time in microseconds per request to \nhost\n since the start of the test.\n\nTest and phase histogram are available as \ntest_http_histogram_responseTime_\nhost\n and \nphase_http_histogram_responseTime_\nhost\n.\n\n\nhttp_counter_responseTime_\nhost\n\n(Optional) Response time in microseconds per request to URI \nuri\n and \nhost\n since the start of the test.\n\nNote: uri is the request path if the plugin is configured with the option texttt{stats_per_url}.\n\n\nhttp_counter_responseTime_\nhost\n_\ngroup\n\nResponse time in microseconds per request tagged with group \ngroup\n to \nhost\n since the start of the test.\n\nNote: uri is the request path if the plugin is configured with the option texttt{stats_per_url}.\n\n\nhttp_histogram_connectionTime_\nhost\n\nConnection time in microseconds to \n since the start of the test. Reports the statistics for the last 60 seconds of testing.\n\nTest and phase histogram are available as \ntest_http_histogram_connectionTime_\nhost\n and \nphase_http_histogram_connectionTime_\nhost\n\n\nhttp_histogram_connectionTime\n\nConnection time in microseconds to each server since the start of the test. Reports the statistics for the last 60 seconds of testing.\n\nTest and phase histogram are available as \ntest_http_histogram_connectionTime\n and \nphase_http_histogram_connectionTime\n \n\nThis histogram is the aggregation of \nhttp_connectionTime_\nhost\n.", 
            "title": "Counters"
        }, 
        {
            "location": "/counters/#counters", 
            "text": "Megaload retrieves all counters and histograms, displaying them in the real-time web dashboard.\nCounters are also used in test and phase assertions to validate the success of the test. A counter can be used in an assertion as the counter value or as a percentage over the total of requests  global_totalRequests .", 
            "title": "Counters"
        }, 
        {
            "location": "/counters/#predefined-counters", 
            "text": "Global counters  Global counters keep track of totals or actuals, including all servers and protocols.  global_counter_users \nThe total running virtual users. \nA virtual user is an instance of a plugin, which can have one or several connections to a server. This counter reports the current total; at the end of the test it resets to 0. \nNote that each scenario can run several virtual users in parallel, either by starting several plugins or plugins with several connections. Thus,  global_counter_users  may be larger than  global_counter_scenarios .   global_counter_scenarios \nNumber of concurrent scenarios.  global_counter_totalRequests \nNumber of requests sent since the start of the test.  global_counter_successfulRequests \nNumber of successful requests sent since the start of the test.  global_counter_failedRequests \nNumber of failed requests sent since the start of the test.  global_counter_invalidRequests \nNumber of invalid requests generated since the start of the test. A request is invalid if it fails before being sent, that is, it is not well-formed. Invalid requests do not increase the counters of total or failed requests.  global_counter_initSections \nNumber of init sections executed since the start of the test.  global_counter_teardownSections \nNumber of teardown sections executed since the start of the test.  global_counter_scenario_ id \nNumber of running scenarios of type  id .  global_counter_totalScenarios_ id \nNumber of scenarios of type  id  executed started since the start of the test.  global_counter_abortedScenarios \nNumber of scenarios which have been aborted since the start of the test.  global_counter_abortedScenarios_ id \nNumber of scenarios of type  id  which have been aborted since the start of the test.   HTTP counters   The following counters are specific to the HTTP protocol.  http_counter_responseSize \nTotal bytes of data received by the HTTP protocol from all servers since the start of the test.  http_counter_responseCode_ code _ host \nNumber of HTTP responses with code  code  from host  host  since the start of the test.  http_counter_connectionRefused_ host \nNumber of connections refused by host  host  since the start of the test. These requests are counted in  global_failedRequests .  http_counter_connectionTimeout_ host \nNumber of connections timeout by host  host  since the start of the test. These requests are counted in  global_failedRequests .  http_counter_connectionError_ host \nNumber of connections failed with a reason different from timeout or refused by host  host  since the start of the test. These requests are counted in  global_failedRequests .  http_counter_timeoutRequests_ host \nNumber of requests timed out by host  host  since the start of the test. This counter is the addition of  http_timeoutRequests_ host _ uri  counters, if present. These requests are counted in  global_failedRequests .  http_counter_timeoutRequests_ host _ uri \n(Optional) Number of requests to URI  uri  timed out by host  host  since the start of the test. These requests are counted in  http_timeoutRequests_ host . \nNote:  uri  is the request path if the plugin is configured with the option  stats_per_url .  http_counter_timeoutRequests_ host _ group \n(Optional) Number of requests tagged with the group  group  and timed out by host  host  since the start of the test. These requests are counted in  http_timeoutRequests_ host . \nNote:  group  is the parameter  group  of the request.  http_counter_successfulRequests_ host \nNumber of successful requests to host  host  since the start of the test. This counter is the addition of  http_successfulRequests_ host _ uri  counters, if present. These requests are counted in  global_successfulRequests . \nNote: A request is successful if it returns a syntactically valid HTTP response and its body and status assertions validate to true, in case such assertions exist. Any syntactically valid HTTP response without assertions is considered successful.  http_counter_successfulRequests_ host _ uri \n(Optional) Number of successful requests to URI  uri  and host  host  since the start of the test. These requests are counted in  http_successfulRequests_ host . \nNote: A request is successful if it returns a syntactically valid HTTP response and its body and status assertions validate to true or are undefined. \nNote:  uri  is the request path if the plugin is configured with the option  stats_per_url .  http_counter_successfulRequests_ host _ group \n(Optional) Number of successful requests tagged with the group  group  to  host  since the start of the test. These requests are counted in  http_successfulRequests_ host . \nNote: A request is successful if it returns a syntactically valid HTTP response and its body and status assertions validate to true or are undefined. \nNote:  group  is the parameter  group  of the request.  http_counter_failedRequests_ host \nNumber of failed requests to host  host  since the start of the test. This counter is the addition of  http_failedRequests_ host _ uri  counters, if present. These requests are counted in  global_failedRequests . \nNote: A request is failed if it returns a syntactically valid HTTP response and its body or status assertions validate to false, in case such assertions exist.  http_counter_failedRequests_ host _ uri \n(Optional) Number of failed requests to URI  uri  and host  host  since the start of the test. These requests are counted as  http_failedRequests_ host . \nNote: A request is failed if it returns a syntactically valid HTTP response and its body or status assertions validate to false. \nNote:  uri  is the request path if the plugin is configured with the option  statss_per_url .   http_counter_failedRequests_ host _ group \n(Optional) Number of failed requests tagged with the group  group  to host  host  since the start of the test. These requests are counted as  http_failedRequests_ host . \nNote: A request is failed if it returns a syntactically valid HTTP response and its body or status assertions validate to false. \nNote:  group  is the parameter  group  of the request.  http_counter_errorRequests_ host \nNumber of error requests to host  host  since the start of the test. These requests are counted in  global_failedRequests . \nNote: A request is counted as an error if the HTTP response is syntactically invalid or the server connection returns an error different from connection refused or connection timeout.  http_counter_errorRequests_ host _ uri \n(Optional) Number of error requests to URI  uri  and host  host  since the start of the test. These requests are counted in  http_errorRequests_ host . \nNote: A request is counted as an error if the HTTP response is syntactically invalid or the server connection returns an error different from connection refused or connection timeout. \nNote:  uri  is the request path if the plugin is configured with the option  stats_per_url .  http_counter_errorRequests_ host _ group \n(Optional) Number of error requests tagged with the group  group  from host  host  since the start of the test. These requests are counted in  http_errorRequests_host . \nNote: A request is counted as an error if the HTTP response is syntactically invalid or the server connection returns an error different from connection refused or connection timeout. \nNote:  group  is the parameter  group  of the request.", 
            "title": "Predefined counters"
        }, 
        {
            "location": "/counters/#custom-counters", 
            "text": "Counters defined by the users in the test specification can be used in assertions. It is currently not possible to define user histograms.  See actions  counter-new ,  counter-inc ,  counter-value .  custom_counter_ counter \nCustom counter defined in the test specification", 
            "title": "Custom counters"
        }, 
        {
            "location": "/counters/#predefined-gauges", 
            "text": "The gauges defined in Megaload provide information about the system itself. They report useful information as the targets for each node or current workload. Sometimes, the test targets may not be meet due to the response of the SUT, but in other cases it will be required to scale up Megaload.\nGauges provide an insight on Megaload itself.  Global gauges  global_gauge_maxRate \nLive local target rate. \nSet based on the target specified in the phase -- if the test is specified as JSON -- or based on the local load regulation mechanism -- if the test is specified as Escript. \nSee  global_histogram_requestsPerSecond  for the local actual rate.  global_gauge_maxWorkers \nLive local target (max) number of workers (scenarios). \nSet based on the target specified in the phase -- if the test is specified as JSON -- or based on the local load regulation mechanism -- if the test is specified as Escript. \nSee  global_counter_scenarios  for the local actual number of workers.  global_gauge_phaseRate \nTarget rate from the current phase.  global_gauge_phaseWorkers \nTarget number of workers (scenarios) from the current phase.  global_gauge_phaseRatePerc \nPercentage of the rate specified in the phase that must be fulfilled by the node.  global_gauge_phaseWorkersPerc \nPercentage of the concurrent scenarios specified in the phase that must be fulfilled by the node.  System monitoring", 
            "title": "Predefined gauges"
        }, 
        {
            "location": "/counters/#predefined-histograms", 
            "text": "Histograms provide statistical information about a value:  min ,  max ,  mean ,  median ,  percentile 50 ,  percentile 75 ,  percentile 90 ,  percentile 95 ,  percentile 99 ,  percentile 999 .  The histograms described in the following subsections report instant values, that is, the histogram for the last 60 seconds. These histograms allow you to monitor very precisely the evolution of the test in execution through the web interface, with the visualization of individual parameters as min, max or means.  Histograms are used in phase assertions and test assertions to validate the success of the test.\nIn order to allow these verifications, there are some special histograms for response times and rate of requests, which provide the response time for the whole of the test or phase. \nTest and phase histograms are displayed in Megaload-UI, preceded by the tags  test_  or  phase_ .  Global histograms    global_histogram_requestsPerSecond \nRate of requests per second. Reports the statistics for the last 60 seconds of testing. Includes all servers and protocols. \nTest and phase histograms are available as  test_global_histogram_requestsPerSecond  and  phase_global_histogram_requestsPerSecond .  global_histogram_unsatisfiedRps \nP0ercentage of the target rate that is not fulfilled by the node.  HTTP histograms   http_histogram_responseSize_ host \nBytes of data received per response from host since the start of the test. Reports the statistics for the last 60 seconds of testing. \nTest and phase histograms are available as  test_http_histogram_responseSize_ host  and  phase_http_histogram_responseSize_ host  http_counter_responseTime \nResponse time in microseconds per request since the start of the test. \nTest and phase histograms are available as  test_http_histogram_responseTime  and  phase_http_histogram_responseTime . \nThis histogram is the aggregation of  http_responseTime_ host .  http_counter_responseTime_ host \nResponse time in microseconds per request to  host  since the start of the test. \nTest and phase histogram are available as  test_http_histogram_responseTime_ host  and  phase_http_histogram_responseTime_ host .  http_counter_responseTime_ host \n(Optional) Response time in microseconds per request to URI  uri  and  host  since the start of the test. \nNote: uri is the request path if the plugin is configured with the option texttt{stats_per_url}.  http_counter_responseTime_ host _ group \nResponse time in microseconds per request tagged with group  group  to  host  since the start of the test. \nNote: uri is the request path if the plugin is configured with the option texttt{stats_per_url}.  http_histogram_connectionTime_ host \nConnection time in microseconds to   since the start of the test. Reports the statistics for the last 60 seconds of testing. \nTest and phase histogram are available as  test_http_histogram_connectionTime_ host  and  phase_http_histogram_connectionTime_ host  http_histogram_connectionTime \nConnection time in microseconds to each server since the start of the test. Reports the statistics for the last 60 seconds of testing. \nTest and phase histogram are available as  test_http_histogram_connectionTime  and  phase_http_histogram_connectionTime   \nThis histogram is the aggregation of  http_connectionTime_ host .", 
            "title": "Predefined histograms"
        }, 
        {
            "location": "/action_time/", 
            "text": "Time\n\n\nTime wait\n\n\n\n\n\nThe \ntime-wait\n action pauses execution for the specified amount of time.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nhours\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in hours for the user to sleep\n\n\n\n\n\n\nminutes\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in minutes for the user to sleep\n\n\n\n\n\n\nseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in seconds for the user to sleep\n\n\n\n\n\n\nmiliseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in milliseconds for the user to sleep\n\n\n\n\n\n\n\n\nThe user must set at least one of the time units. The total time in milliseconds is used as sleep time.\n\n\nExample\n\n\n{\ntime-wait\n : { \nminutes\n : 10 } }\n\n\n\n\nTime random wait\n\n\nThe \ntime-random_wait\n action pauses execution for an unspecified amount of time.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nhours\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in hours for the user to sleep\n\n\n\n\n\n\nminutes\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in minutes for the user to sleep\n\n\n\n\n\n\nseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in seconds for the user to sleep\n\n\n\n\n\n\nmiliseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in milliseconds for the user to sleep\n\n\n\n\n\n\n\n\nThe user must set at least one of the time units. The total time in milliseconds is used to choose a random value between 1 and the total.\n\n\nExample\n\n\n{\ntime-random_wait\n : { \nminutes\n : 10 } }\n\n\n\n\nTime now\n\n\nThe \ntime-now\n action returns the time in milliseconds since 1/1/1970.\n\n\nExample\n\n\n{\ntime-now\n : {  } }\n\n\n\n\nTime date\n\n\nThe \ntime-date\n action returns the time in milliseconds since 1/1/1970 from the actual date plus \nhours\n from midnight.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nhours\n\n\ninteger\n\n\nno\n\n\nno\n\n\nHours from midnight.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ntime-date\n : {\nhours\n : 2} }\n\n\n\n\nTime past\n\n\nThe \ntime-past\n action returns the time in milliseconds since 1/1/1970 minus the specified amount of time.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nhours\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in hours for the user to sleep.\n\n\n\n\n\n\nminutes\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in minutes for the user to sleep.\n\n\n\n\n\n\nseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in seconds for the user to sleep.\n\n\n\n\n\n\nmiliseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in milliseconds for the user to sleep.\n\n\n\n\n\n\n\n\nAt least one of the time units should be specified.\n\n\nExample\n\n\n{\ntime-past\n : { \nminutes\n : 10, \u201chours\u201d : 1 } }\n\n\n\n\nTime future\n\n\nThe \ntime-future\n action returns the time in milliseconds since 1/1/1970 plus the specified amount of time.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nhours\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in hours for the user to sleep.\n\n\n\n\n\n\nminutes\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in minutes for the user to sleep.\n\n\n\n\n\n\nseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in seconds for the user to sleep.\n\n\n\n\n\n\nmiliseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in milliseconds for the user to sleep.\n\n\n\n\n\n\n\n\nAt least one of the time units should be specified.\n\n\nExample\n\n\n{\ntime-future\n : { \nminutes\n : 10, \u201chours\u201d : 1 } }", 
            "title": "Time"
        }, 
        {
            "location": "/action_time/#time", 
            "text": "", 
            "title": "Time"
        }, 
        {
            "location": "/action_time/#time-wait", 
            "text": "The  time-wait  action pauses execution for the specified amount of time.     Name  Type  Required  Action  Info      hours  integer  No  No  Time in hours for the user to sleep    minutes  integer  No  No  Time in minutes for the user to sleep    seconds  integer  No  No  Time in seconds for the user to sleep    miliseconds  integer  No  No  Time in milliseconds for the user to sleep     The user must set at least one of the time units. The total time in milliseconds is used as sleep time.  Example  { time-wait  : {  minutes  : 10 } }", 
            "title": "Time wait"
        }, 
        {
            "location": "/action_time/#time-random-wait", 
            "text": "The  time-random_wait  action pauses execution for an unspecified amount of time.     Name  Type  Required  Action  Info      hours  integer  No  No  Time in hours for the user to sleep    minutes  integer  No  No  Time in minutes for the user to sleep    seconds  integer  No  No  Time in seconds for the user to sleep    miliseconds  integer  No  No  Time in milliseconds for the user to sleep     The user must set at least one of the time units. The total time in milliseconds is used to choose a random value between 1 and the total.  Example  { time-random_wait  : {  minutes  : 10 } }", 
            "title": "Time random wait"
        }, 
        {
            "location": "/action_time/#time-now", 
            "text": "The  time-now  action returns the time in milliseconds since 1/1/1970.  Example  { time-now  : {  } }", 
            "title": "Time now"
        }, 
        {
            "location": "/action_time/#time-date", 
            "text": "The  time-date  action returns the time in milliseconds since 1/1/1970 from the actual date plus  hours  from midnight.     Name  Type  Required  Action  Info      hours  integer  no  no  Hours from midnight.     Example  { time-date  : { hours  : 2} }", 
            "title": "Time date"
        }, 
        {
            "location": "/action_time/#time-past", 
            "text": "The  time-past  action returns the time in milliseconds since 1/1/1970 minus the specified amount of time.     Name  Type  Required  Action  Info      hours  integer  No  No  Time in hours for the user to sleep.    minutes  integer  No  No  Time in minutes for the user to sleep.    seconds  integer  No  No  Time in seconds for the user to sleep.    miliseconds  integer  No  No  Time in milliseconds for the user to sleep.     At least one of the time units should be specified.  Example  { time-past  : {  minutes  : 10, \u201chours\u201d : 1 } }", 
            "title": "Time past"
        }, 
        {
            "location": "/action_time/#time-future", 
            "text": "The  time-future  action returns the time in milliseconds since 1/1/1970 plus the specified amount of time.     Name  Type  Required  Action  Info      hours  integer  No  No  Time in hours for the user to sleep.    minutes  integer  No  No  Time in minutes for the user to sleep.    seconds  integer  No  No  Time in seconds for the user to sleep.    miliseconds  integer  No  No  Time in milliseconds for the user to sleep.     At least one of the time units should be specified.  Example  { time-future  : {  minutes  : 10, \u201chours\u201d : 1 } }", 
            "title": "Time future"
        }, 
        {
            "location": "/action_csv/", 
            "text": "CSV handling\n\n\nOpen CSV file\n\n\nThe \ndata-csv\n action specifies a CSV file from which data will be read.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCSV filename. It must be uploaded in the system using the \nload data\n API.\n\n\n\n\n\n\nname\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nIdentifier given to the file to use in read operations.\n\n\n\n\n\n\nheaders\n\n\nboolean\n\n\nNo\n\n\nNo\n\n\nIndicates the presence of headers on the file; the default is \"false\".\n\n\n\n\n\n\n\n\nExample\n\n\n{\ndata-csv\n : {\n                \nfile\n : \ncsv_e2e.csv\n,\n                \nname\n : \ncsvdata\n\n              }\n}\n\n\n\n\nNote:\n The fields in CSV fiels should be seperated by commas only. Quotation marks are not required unless they should be included in the field value.\n\n\nRead CSV file\n\n\nThe \ndata-csv_value\n action loads each line from the CSV file specified in the \ndata-csv\n action. It uses circular reading, so it will start reading again from the beginning once the end is reached. This action retrieves one line at each time. Fields are stored in the variables provided. \nfields\n and \nvars\n must contain the same number of elements. The action returns \n'ok'\n.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nFile identifier.\n\n\n\n\n\n\nfields\n\n\nlist of integer\n\n\nYes\n\n\nNo\n\n\nNumbers of the CSV columns to be retrieved.\n\n\n\n\n\n\nvars\n\n\nlist of string\n\n\nYes\n\n\nNo\n\n\nNames of the variables to store the retrieved fields.\n\n\n\n\n\n\n\n\nA row can be read by using field indexes in ascending order. Note that the field index starts with 1 (so the index of the first value in a line is 1).  \n\n\nExample\n\n\n{\ndata-csv_value\n : {\n                \nname\n : \ncsvdata\n,\n                \nfields\n : [1,3],\n                \nvars\n : [\nname\n,\ndate\n]\n              }\n}", 
            "title": "CSV handling"
        }, 
        {
            "location": "/action_csv/#csv-handling", 
            "text": "", 
            "title": "CSV handling"
        }, 
        {
            "location": "/action_csv/#open-csv-file", 
            "text": "The  data-csv  action specifies a CSV file from which data will be read.     Name  Type  Required  Action  Info      file  string  Yes  No  CSV filename. It must be uploaded in the system using the  load data  API.    name  string  Yes  No  Identifier given to the file to use in read operations.    headers  boolean  No  No  Indicates the presence of headers on the file; the default is \"false\".     Example  { data-csv  : {\n                 file  :  csv_e2e.csv ,\n                 name  :  csvdata \n              }\n}  Note:  The fields in CSV fiels should be seperated by commas only. Quotation marks are not required unless they should be included in the field value.", 
            "title": "Open CSV file"
        }, 
        {
            "location": "/action_csv/#read-csv-file", 
            "text": "The  data-csv_value  action loads each line from the CSV file specified in the  data-csv  action. It uses circular reading, so it will start reading again from the beginning once the end is reached. This action retrieves one line at each time. Fields are stored in the variables provided.  fields  and  vars  must contain the same number of elements. The action returns  'ok' .     Name  Type  Required  Action  Info      name  string  Yes  No  File identifier.    fields  list of integer  Yes  No  Numbers of the CSV columns to be retrieved.    vars  list of string  Yes  No  Names of the variables to store the retrieved fields.     A row can be read by using field indexes in ascending order. Note that the field index starts with 1 (so the index of the first value in a line is 1).    Example  { data-csv_value  : {\n                 name  :  csvdata ,\n                 fields  : [1,3],\n                 vars  : [ name , date ]\n              }\n}", 
            "title": "Read CSV file"
        }, 
        {
            "location": "/action_stat_counter/", 
            "text": "Statistical counters\n\n\nThese counters are part of Megaload statistics and will be collected and aggregated by the system. They can be viewed in the web dashboard. the user can define new custom counters with this action, which will be labellled with the \"custom\" tag. Predefined counters cannot be modified with these actions.\n\n\nNew counter\n\n\nThe \ncounter\n action defines a new counter.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncounter\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCounter identifier.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nstat_counter-new\n : {\n                        \ncounter\n : \ncount_valid_answer\n\n                      }\n}\n\n\n\n\nCounter increment\n\n\nThe \nstat_counter-inc\n action increments a counter with the specified value.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncounter\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCounter identifier.\n\n\n\n\n\n\nincrement\n\n\ninteger\n\n\nYes\n\n\nYes\n\n\nCounter increment. It accepts actions that evaluate to integers.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nstat_counter-inc\n : {\n                        \ncounter\n : \ncount_valid_answer\n,\n                        \nincrement\n : 1\n                      }\n}\n\n\n\n\nCounter value\n\n\nThe \nstat_counter-value\n action retrieves the current value of the counter.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncounter\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCounter identifier.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nstat_counter-value\n : {\n                          \ncounter\n : \ncount_valid_answer\n\n                        }\n}", 
            "title": "Statistical counters"
        }, 
        {
            "location": "/action_stat_counter/#statistical-counters", 
            "text": "These counters are part of Megaload statistics and will be collected and aggregated by the system. They can be viewed in the web dashboard. the user can define new custom counters with this action, which will be labellled with the \"custom\" tag. Predefined counters cannot be modified with these actions.", 
            "title": "Statistical counters"
        }, 
        {
            "location": "/action_stat_counter/#new-counter", 
            "text": "The  counter  action defines a new counter.     Name  Type  Required  Action  Info      counter  string  Yes  No  Counter identifier.     Example  { stat_counter-new  : {\n                         counter  :  count_valid_answer \n                      }\n}", 
            "title": "New counter"
        }, 
        {
            "location": "/action_stat_counter/#counter-increment", 
            "text": "The  stat_counter-inc  action increments a counter with the specified value.     Name  Type  Required  Action  Info      counter  string  Yes  No  Counter identifier.    increment  integer  Yes  Yes  Counter increment. It accepts actions that evaluate to integers.     Example  { stat_counter-inc  : {\n                         counter  :  count_valid_answer ,\n                         increment  : 1\n                      }\n}", 
            "title": "Counter increment"
        }, 
        {
            "location": "/action_stat_counter/#counter-value", 
            "text": "The  stat_counter-value  action retrieves the current value of the counter.     Name  Type  Required  Action  Info      counter  string  Yes  No  Counter identifier.     Example  { stat_counter-value  : {\n                           counter  :  count_valid_answer \n                        }\n}", 
            "title": "Counter value"
        }, 
        {
            "location": "/action_test_counter/", 
            "text": "Test counters\n\n\nUsed for value generation in the test specification, as Session-Id. These counters are not reflected in the statistics. Each counter represents an unique generator per node, global for all the users on that node.\n\n\nNew counter\n\n\nThe \ncounter-new\n action defines a new counter.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncounter\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCounter identifier.\n\n\n\n\n\n\nvalue\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nInitial value.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncounter-new\n : {\n                   \ncounter\n : \nSession-Id\n\n                 }\n}\n\n\n\n\nCounter increment\n\n\nThe \ncounter-inc\n action increments a counter with the specified value.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncounter\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCounter identifier.\n\n\n\n\n\n\nincrement\n\n\ninteger\n\n\nYes\n\n\nYes\n\n\nCounter increment.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncounter-inc\n : {\n                   \ncounter\n : \nSession-Id\n,\n                   \nincrement\n : 1\n                 }\n}\n\n\n\n\nCounter value\n\n\nThe \ncounter-value\n action retrieves the current value of the counter.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncounter\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nCounter identifier.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncounter-value\n : {\n                     \ncounter\n : \nSession-Id\n\n                   }\n}", 
            "title": "Test counters"
        }, 
        {
            "location": "/action_test_counter/#test-counters", 
            "text": "Used for value generation in the test specification, as Session-Id. These counters are not reflected in the statistics. Each counter represents an unique generator per node, global for all the users on that node.", 
            "title": "Test counters"
        }, 
        {
            "location": "/action_test_counter/#new-counter", 
            "text": "The  counter-new  action defines a new counter.     Name  Type  Required  Action  Info      counter  string  Yes  No  Counter identifier.    value  integer  No  No  Initial value.     Example  { counter-new  : {\n                    counter  :  Session-Id \n                 }\n}", 
            "title": "New counter"
        }, 
        {
            "location": "/action_test_counter/#counter-increment", 
            "text": "The  counter-inc  action increments a counter with the specified value.     Name  Type  Required  Action  Info      counter  string  Yes  No  Counter identifier.    increment  integer  Yes  Yes  Counter increment.     Example  { counter-inc  : {\n                    counter  :  Session-Id ,\n                    increment  : 1\n                 }\n}", 
            "title": "Counter increment"
        }, 
        {
            "location": "/action_test_counter/#counter-value", 
            "text": "The  counter-value  action retrieves the current value of the counter.     Name  Type  Required  Action  Info      counter  string  Yes  No  Counter identifier.     Example  { counter-value  : {\n                      counter  :  Session-Id \n                   }\n}", 
            "title": "Counter value"
        }, 
        {
            "location": "/action_generic_checks/", 
            "text": "Generic checks\n\n\nEqual\n\n\nThe \ncheck-eq\n action checks whether the two values provided are equal.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nleft\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nLeft member of the comparison.\n\n\n\n\n\n\nright\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nRight member of the comparison.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncheck-eq\n : {\n       \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n       \nright\n : 3\n              }\n}\n\n\n\n\nNot equal\n\n\nThe \ncheck-neq\n action checks whether the two values provided are different.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nleft\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nLeft member of the comparison.\n\n\n\n\n\n\nright\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nRight member of the comparison.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncheck-neq\n : {\n       \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } }\n       \nright\n : 3\n               }\n}\n\n\n\n\nLess than\n\n\nThe \ncheck-lt\n action checks that the \"left\" value is smaller than the \"right\" value.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nleft\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nLeft member of the comparison.\n\n\n\n\n\n\nright\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nRight member of the comparison.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncheck-lt\n : {\n       \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n       \nright\n : 3\n               }\n}\n\n\n\n\nGreater than\n\n\nThe \ncheck-gt\n action checks that the \"left\" value is greater than the \"right\" value.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nleft\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nLeft member of the comparison.\n\n\n\n\n\n\nright\n\n\nbasic\n\n\nYes\n\n\nYes\n\n\nRight member of the comparison.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncheck-gt\n : {\n       \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n       \nright\n : 3\n               }\n}\n\n\n\n\nAll\n\n\nThe \ncheck-all\n action takes a list of conditions (such as the generic checks listed above) and checks that all of them evaluate to true.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nconditions\n\n\nne-list of objects\n\n\nYes\n\n\nNo\n\n\nList of conditions. A condition is an action that evaluates to a boolean.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncheck-all\n : {\n                 \nconditions\n :\n                       [\n                        {\ncheck-eq\n :\n                                      \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n                                      \nright\n : 3\n                        }\n                       ]\n               }\n}\n\n\n\n\nAny\n\n\nThe \ncheck-any\n action takes a list of conditions (such as the generic checks listed above) and checks that at least one of them evaluates to true.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nconditions\n\n\nne-list of objects\n\n\nYes\n\n\nNo\n\n\nList of conditions. A condition is an action that evaluates to a boolean.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncheck-any\n : {\n                 \nconditions\n :\n                       [\n                        {\ncheck-eq\n :\n                                      \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n                                      \nright\n : 3\n                        }\n                       ]\n               }\n}", 
            "title": "Generic checks"
        }, 
        {
            "location": "/action_generic_checks/#generic-checks", 
            "text": "", 
            "title": "Generic checks"
        }, 
        {
            "location": "/action_generic_checks/#equal", 
            "text": "The  check-eq  action checks whether the two values provided are equal.     Name  Type  Required  Action  Info      left  basic  Yes  Yes  Left member of the comparison.    right  basic  Yes  Yes  Right member of the comparison.     Example  { check-eq  : {\n        left  : {  counter-value  : {  counter  :  Session-Id  } },\n        right  : 3\n              }\n}", 
            "title": "Equal"
        }, 
        {
            "location": "/action_generic_checks/#not-equal", 
            "text": "The  check-neq  action checks whether the two values provided are different.     Name  Type  Required  Action  Info      left  basic  Yes  Yes  Left member of the comparison.    right  basic  Yes  Yes  Right member of the comparison.     Example  { check-neq  : {\n        left  : {  counter-value  : {  counter  :  Session-Id  } }\n        right  : 3\n               }\n}", 
            "title": "Not equal"
        }, 
        {
            "location": "/action_generic_checks/#less-than", 
            "text": "The  check-lt  action checks that the \"left\" value is smaller than the \"right\" value.     Name  Type  Required  Action  Info      left  basic  Yes  Yes  Left member of the comparison.    right  basic  Yes  Yes  Right member of the comparison.     Example  { check-lt  : {\n        left  : {  counter-value  : {  counter  :  Session-Id  } },\n        right  : 3\n               }\n}", 
            "title": "Less than"
        }, 
        {
            "location": "/action_generic_checks/#greater-than", 
            "text": "The  check-gt  action checks that the \"left\" value is greater than the \"right\" value.     Name  Type  Required  Action  Info      left  basic  Yes  Yes  Left member of the comparison.    right  basic  Yes  Yes  Right member of the comparison.     Example  { check-gt  : {\n        left  : {  counter-value  : {  counter  :  Session-Id  } },\n        right  : 3\n               }\n}", 
            "title": "Greater than"
        }, 
        {
            "location": "/action_generic_checks/#all", 
            "text": "The  check-all  action takes a list of conditions (such as the generic checks listed above) and checks that all of them evaluate to true.     Name  Type  Required  Action  Info      conditions  ne-list of objects  Yes  No  List of conditions. A condition is an action that evaluates to a boolean.     Example  { check-all  : {\n                  conditions  :\n                       [\n                        { check-eq  :\n                                       left  : {  counter-value  : {  counter  :  Session-Id  } },\n                                       right  : 3\n                        }\n                       ]\n               }\n}", 
            "title": "All"
        }, 
        {
            "location": "/action_generic_checks/#any", 
            "text": "The  check-any  action takes a list of conditions (such as the generic checks listed above) and checks that at least one of them evaluates to true.     Name  Type  Required  Action  Info      conditions  ne-list of objects  Yes  No  List of conditions. A condition is an action that evaluates to a boolean.     Example  { check-any  : {\n                  conditions  :\n                       [\n                        { check-eq  :\n                                       left  : {  counter-value  : {  counter  :  Session-Id  } },\n                                       right  : 3\n                        }\n                       ]\n               }\n}", 
            "title": "Any"
        }, 
        {
            "location": "/action_logical/", 
            "text": "Logical operators\n\n\nNot\n\n\nThe \nlogic-not\n action performs logical negation of an action, returning \nfalse\n (for example) if the action evaluates to \ntrue\n.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nright\n\n\naction\n\n\nYes\n\n\nYes\n\n\nNegation of the action.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nlogic-not\n : {\n      \nright\n : {\ncheck-gt\n : {\n                      \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n                      \nright\n : 3\n                              }\n                }\n               }\n}\n\n\n\n\nAnd\n\n\nThe \nlogic-and\n performs a logical comparison of two items, returning \ntrue\n \n(for example) if both of the actions evaluate to \ntrue\n. \n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nright\n\n\naction\n\n\nYes\n\n\nYes\n\n\nRight member of the logical operation. Must evaluate to a boolean.\n\n\n\n\n\n\nleft\n\n\naction\n\n\nYes\n\n\nYes\n\n\nLeft member of the logical operation. Must evaluate to a boolean.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nlogic-and\n : {\n          \nleft\n : {\ncheck-gt\n : {\n                                  \nleft\n : { \ncounter-value\n : {\ncounter\n:\nUser-Id\n}},\n                                  \nright\n : 5\n                                  }\n                   },\n          \nright\n : {\ncheck-gt\n : {\n                                   \nleft\n : { \ncounter-value\n : {\ncounter\n:\nSession-Id\n}},\n                                   \nright\n : 3\n                                  }\n                    }\n                }\n}\n\n\n\n\nOr\n\n\nThe \nlogic-or\n action performs a logical Or-comparison between the \nleft\n and \nright\n items.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nright\n\n\naction\n\n\nYes\n\n\nYes\n\n\nRight member of the logical operation. Must evaluate to a boolean.\n\n\n\n\n\n\nleft\n\n\naction\n\n\nYes\n\n\nYes\n\n\nLeft member of the logical operation. Must evaluate to a boolean.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nlogic-or\n : {\n         \nleft\n : {\ncheck-gt\n : {\n                                 \nleft\n : { \ncounter-value\n : { \ncounter\n : \nUser-Id\n } },\n                                 \nright\n : 5\n                                }\n                   },\n         \nright\n : {\ncheck-gt\n : {\n                                  \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n                                   \nright\n : 3\n                                  }\n                    }\n              }\n}", 
            "title": "Logical operators"
        }, 
        {
            "location": "/action_logical/#logical-operators", 
            "text": "", 
            "title": "Logical operators"
        }, 
        {
            "location": "/action_logical/#not", 
            "text": "The  logic-not  action performs logical negation of an action, returning  false  (for example) if the action evaluates to  true .     Name  Type  Required  Action  Info      right  action  Yes  Yes  Negation of the action.     Example  { logic-not  : {\n       right  : { check-gt  : {\n                       left  : {  counter-value  : {  counter  :  Session-Id  } },\n                       right  : 3\n                              }\n                }\n               }\n}", 
            "title": "Not"
        }, 
        {
            "location": "/action_logical/#and", 
            "text": "The  logic-and  performs a logical comparison of two items, returning  true  \n(for example) if both of the actions evaluate to  true .      Name  Type  Required  Action  Info      right  action  Yes  Yes  Right member of the logical operation. Must evaluate to a boolean.    left  action  Yes  Yes  Left member of the logical operation. Must evaluate to a boolean.     Example  { logic-and  : {\n           left  : { check-gt  : {\n                                   left  : {  counter-value  : { counter : User-Id }},\n                                   right  : 5\n                                  }\n                   },\n           right  : { check-gt  : {\n                                    left  : {  counter-value  : { counter : Session-Id }},\n                                    right  : 3\n                                  }\n                    }\n                }\n}", 
            "title": "And"
        }, 
        {
            "location": "/action_logical/#or", 
            "text": "The  logic-or  action performs a logical Or-comparison between the  left  and  right  items.     Name  Type  Required  Action  Info      right  action  Yes  Yes  Right member of the logical operation. Must evaluate to a boolean.    left  action  Yes  Yes  Left member of the logical operation. Must evaluate to a boolean.     Example  { logic-or  : {\n          left  : { check-gt  : {\n                                  left  : {  counter-value  : {  counter  :  User-Id  } },\n                                  right  : 5\n                                }\n                   },\n          right  : { check-gt  : {\n                                   left  : {  counter-value  : {  counter  :  Session-Id  } },\n                                    right  : 3\n                                  }\n                    }\n              }\n}", 
            "title": "Or"
        }, 
        {
            "location": "/action_control/", 
            "text": "Control structures\n\n\nIf\n\n\nThe \ncontrol-if\n action conditionally executes a group of actions, depending on the boolean value of the \ncondition\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\naction\n\n\nYes\n\n\nYes\n\n\nCondition for the \"if\" control. The action must evaluate to a boolean. Can be a combination of checks and logical operations.\n\n\n\n\n\n\nthen\n\n\nlist of actions\n\n\nYes\n\n\nNo\n\n\nSequence of actions.\n\n\n\n\n\n\nelse\n\n\nlist of actions\n\n\nNo\n\n\nNo\n\n\nSequence of actions.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncontrol-if\n : {\n         \ncondition\n: { \ncheck-eq\n : {\n                                       \nleft\n : {\ncounter-value\n:{\ncounter\n:\nSession-Id\n}},\n                                       \nright\n : 3\n                                       }\n                       },\n          \nthen\n : [\n                     {\ncounter-inc\n : {\n                                        \ncounter\n : \nSession-Id\n,\n                                        \nincrement\n : 1\n                                      }\n                     }\n                   ],\n           \nelse\n : [\n                      {\ncounter-inc\n : {\n                                         \ncounter\n : \nSession-Id\n,\n                                         \nincrement\n : 10\n                                        }\n                      }\n                    ]\n                }\n}\n\n\n\n\nAbort\n\n\nThe \ncontrol-abort\n action aborts the scenario execution if condition returns \nfalse\n.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\naction\n\n\nYes\n\n\nYes\n\n\nCondition for the \u2018abort\u2019 control.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncontrol-abort\n : {\n        \ncondition\n : {\ncheck-gt\n : {\n                             \nleft\n : { \ncounter-value\n : { \ncounter\n : \nSession-Id\n } },\n                             \nright\n : 3\n                                    }\n                      }\n                   }\n}\n\n\n\n\nFor\n\n\nThe \ncontrol-for\n action executes a sequence of actions a specified number of times.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nfrom\n\n\ninteger\n\n\nYes\n\n\nYes\n\n\nCounter initialization.\n\n\n\n\n\n\nto\n\n\ninteger\n\n\nYes\n\n\nYes\n\n\nCounter end.\n\n\n\n\n\n\nthen\n\n\nlist of actions\n\n\nYes\n\n\nNo\n\n\nSequence of actions.\n\n\n\n\n\n\n\n\nExecutes a list of actions \\textit{from} to \\textit{to} times.\n\n\nExample\n\n\n{\ncontrol-for\n : {\n                   \nfrom\n : 1,\n                   \nto\n : 10,\n                   \nthen\n : [\n                             {\ncounter-inc\n : {\n                                      \ncounter\n : \nSession-Id\n,\n                                      \nincrement\n : 1\n                                              }\n                             }\n                            ]\n                 }\n}\n\n\n\n\nWhile\n\n\nThe \ncontrol-while\n action executes a sequence of actions as long as the specified \ncondition\n is true.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\naction\n\n\nYes\n\n\nYes\n\n\nCondition for the \u2018while\u2019 control. The action must evaluate to a boolean. Can be a combination of checks and logical operations.\n\n\n\n\n\n\nthen\n\n\nlist of actions\n\n\nYes\n\n\nNo\n\n\nSequence of actions.\n\n\n\n\n\n\n\n\nExample\n\n\n{\ncontrol-while\n : {\n          \ncondition\n: { \ncheck-eq\n : {\n                                        \nleft\n : {\ncounter-value\n:{\ncounter\n:\nSession-Id\n}},\n                                        \nright\n : 3\n                                      }\n                       },\n          \nthen\n : [\n                     {\ncounter-inc\n : {\n                                        \ncounter\n : \nSession-Id\n,\n                                        \nincrement\n : 1\n                                      }\n                     }\n                   ]\n                  }\n}\n\n\n\n\nPeriodic\n\n\nThe \ncontrol-periodic\n action can be used to repeat a sequence of actions at a specified interval. The periodic action is interleaved with the rest of actions in the scenario, but it is not enough to keep a scenario running. Once all other actions are finished, the scenario will finish.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nactions\n\n\nlist of actions\n\n\nYes\n\n\nNo\n\n\nSequence of actions.\n\n\n\n\n\n\nmilliseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in milliseconds.\n\n\n\n\n\n\nseconds\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in seconds.\n\n\n\n\n\n\nminutes\n\n\ninteger\n\n\nNo\n\n\nNo\n\n\nTime in minutes.\n\n\n\n\n\n\n\n\nAt least one of the time units must be specified. The time will be added and the total of milliseconds used as a \"wait time\". The list of actions will be executed periodically every time after the \"wait time\".\n\n\nExample\n\n\n{\ncontrol-periodic\n : {\n               \nminutes\n : 5,\n               \nactions\n : [\n                             {\ncounter-inc\n : {\n                                      \ncounter\n : \nSession-Id\n,\n                                      \nincrement\n : 1\n                                              }\n                                      }\n                                    ]\n                      }\n}", 
            "title": "Control structures"
        }, 
        {
            "location": "/action_control/#control-structures", 
            "text": "", 
            "title": "Control structures"
        }, 
        {
            "location": "/action_control/#if", 
            "text": "The  control-if  action conditionally executes a group of actions, depending on the boolean value of the  condition     Name  Type  Required  Action  Info      condition  action  Yes  Yes  Condition for the \"if\" control. The action must evaluate to a boolean. Can be a combination of checks and logical operations.    then  list of actions  Yes  No  Sequence of actions.    else  list of actions  No  No  Sequence of actions.     Example  { control-if  : {\n          condition : {  check-eq  : {\n                                        left  : { counter-value :{ counter : Session-Id }},\n                                        right  : 3\n                                       }\n                       },\n           then  : [\n                     { counter-inc  : {\n                                         counter  :  Session-Id ,\n                                         increment  : 1\n                                      }\n                     }\n                   ],\n            else  : [\n                      { counter-inc  : {\n                                          counter  :  Session-Id ,\n                                          increment  : 10\n                                        }\n                      }\n                    ]\n                }\n}", 
            "title": "If"
        }, 
        {
            "location": "/action_control/#abort", 
            "text": "The  control-abort  action aborts the scenario execution if condition returns  false .     Name  Type  Required  Action  Info      condition  action  Yes  Yes  Condition for the \u2018abort\u2019 control.     Example  { control-abort  : {\n         condition  : { check-gt  : {\n                              left  : {  counter-value  : {  counter  :  Session-Id  } },\n                              right  : 3\n                                    }\n                      }\n                   }\n}", 
            "title": "Abort"
        }, 
        {
            "location": "/action_control/#for", 
            "text": "The  control-for  action executes a sequence of actions a specified number of times.     Name  Type  Required  Action  Info      from  integer  Yes  Yes  Counter initialization.    to  integer  Yes  Yes  Counter end.    then  list of actions  Yes  No  Sequence of actions.     Executes a list of actions \\textit{from} to \\textit{to} times.  Example  { control-for  : {\n                    from  : 1,\n                    to  : 10,\n                    then  : [\n                             { counter-inc  : {\n                                       counter  :  Session-Id ,\n                                       increment  : 1\n                                              }\n                             }\n                            ]\n                 }\n}", 
            "title": "For"
        }, 
        {
            "location": "/action_control/#while", 
            "text": "The  control-while  action executes a sequence of actions as long as the specified  condition  is true.     Name  Type  Required  Action  Info      condition  action  Yes  Yes  Condition for the \u2018while\u2019 control. The action must evaluate to a boolean. Can be a combination of checks and logical operations.    then  list of actions  Yes  No  Sequence of actions.     Example  { control-while  : {\n           condition : {  check-eq  : {\n                                         left  : { counter-value :{ counter : Session-Id }},\n                                         right  : 3\n                                      }\n                       },\n           then  : [\n                     { counter-inc  : {\n                                         counter  :  Session-Id ,\n                                         increment  : 1\n                                      }\n                     }\n                   ]\n                  }\n}", 
            "title": "While"
        }, 
        {
            "location": "/action_control/#periodic", 
            "text": "The  control-periodic  action can be used to repeat a sequence of actions at a specified interval. The periodic action is interleaved with the rest of actions in the scenario, but it is not enough to keep a scenario running. Once all other actions are finished, the scenario will finish.     Name  Type  Required  Action  Info      actions  list of actions  Yes  No  Sequence of actions.    milliseconds  integer  No  No  Time in milliseconds.    seconds  integer  No  No  Time in seconds.    minutes  integer  No  No  Time in minutes.     At least one of the time units must be specified. The time will be added and the total of milliseconds used as a \"wait time\". The list of actions will be executed periodically every time after the \"wait time\".  Example  { control-periodic  : {\n                minutes  : 5,\n                actions  : [\n                             { counter-inc  : {\n                                       counter  :  Session-Id ,\n                                       increment  : 1\n                                              }\n                                      }\n                                    ]\n                      }\n}", 
            "title": "Periodic"
        }, 
        {
            "location": "/action_variable/", 
            "text": "Variables\n\n\nVariables are used to store values and can be passed as parameters in some actions.\n\n\n\n\n\nOne special variable is \n$http-answer\n which stores the result of the last HTTP request. Some actions, such as those related to JSON manipulation, can use this as an implicit variable.\n\n\n$http-answer\n cannot be set by the user, but its value can be retrieved with the \nvar-get\n action.\n\n\nGet\n\n\nThe \nvar-get\n action returns the value stored in a variable.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nYes\n\n\nYes\n\n\nVariable name.\n\n\n\n\n\n\n\n\n{\nvar-get\n : {\n               \nname\n : \u201ctotal_credit\u201d\n             }\n}\n\n\n\n\nSet\n\n\nThe \nvar-set\n action stores a value in a variable. The value can have any type.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nYes\n\n\nYes\n\n\nVariable name.\n\n\n\n\n\n\nvalue\n\n\nany\n\n\nYes\n\n\nYes\n\n\nVariable value.\n\n\n\n\n\n\n\n\n{\nvar-set\n : {\n               \nname\n : \ntotal_credit\n,\n               \nvalue\n : {\n                          \ncounter-value\n : {\n                                              \ncounter\n : \ncredit\n\n                                            }\n                         }\n             }\n}", 
            "title": "Variables"
        }, 
        {
            "location": "/action_variable/#variables", 
            "text": "Variables are used to store values and can be passed as parameters in some actions.   One special variable is  $http-answer  which stores the result of the last HTTP request. Some actions, such as those related to JSON manipulation, can use this as an implicit variable.  $http-answer  cannot be set by the user, but its value can be retrieved with the  var-get  action.", 
            "title": "Variables"
        }, 
        {
            "location": "/action_variable/#get", 
            "text": "The  var-get  action returns the value stored in a variable.     Name  Type  Required  Action  Info      name  string  Yes  Yes  Variable name.     { var-get  : {\n                name  : \u201ctotal_credit\u201d\n             }\n}", 
            "title": "Get"
        }, 
        {
            "location": "/action_variable/#set", 
            "text": "The  var-set  action stores a value in a variable. The value can have any type.     Name  Type  Required  Action  Info      name  string  Yes  Yes  Variable name.    value  any  Yes  Yes  Variable value.     { var-set  : {\n                name  :  total_credit ,\n                value  : {\n                           counter-value  : {\n                                               counter  :  credit \n                                            }\n                         }\n             }\n}", 
            "title": "Set"
        }, 
        {
            "location": "/action_url/", 
            "text": "URL handling\n\n\nJoin\n\n\nThe \nurl-join\n action builds a new URL by joining the root and a relative path.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nroot\n\n\nstring\n\n\nYes\n\n\nYes\n\n\nRoot path.\n\n\n\n\n\n\npath\n\n\nstring\n\n\nYes\n\n\nYes\n\n\nRelative path to \nroot\n.\n\n\n\n\n\n\n\n\n{\nurl-join\n : {\n                \nroot\n : \n/credit_account/user\n,\n                \npath\n : {\nvar-get\n : {\n                                        \nname\n : \nUser-Id\n\n                                      }\n                         }\n              }\n}", 
            "title": "URL handling"
        }, 
        {
            "location": "/action_url/#url-handling", 
            "text": "", 
            "title": "URL handling"
        }, 
        {
            "location": "/action_url/#join", 
            "text": "The  url-join  action builds a new URL by joining the root and a relative path.     Name  Type  Required  Action  Info      root  string  Yes  Yes  Root path.    path  string  Yes  Yes  Relative path to  root .     { url-join  : {\n                 root  :  /credit_account/user ,\n                 path  : { var-get  : {\n                                         name  :  User-Id \n                                      }\n                         }\n              }\n}", 
            "title": "Join"
        }, 
        {
            "location": "/action_json/", 
            "text": "JSON handling\n\n\nJSONPath actions support JSON manipulation on HTTP requests and responses. HTTP responses are stored in a special variable (see \nVariables\n) to avoid the user having to store and retrieve on following checks. See \nHTTP\n for information on the format of the HTTP responses. \n\n\nCurrently, only two kind of queries are allowed with JSONPath:\n\n\n\n\nNested object/member expressions: \nstore.book\n\n\nArray expression: \nstore.book[1].title\n\n\nArray index starts at 0\n\n\nrandom\n chooses a random index in the length of the array: \nstore.book[random].title\n\n\n\n\n\n\n\n\nJSONPath will be extended to support more XPath-like expressions.\n\n\n\n\n\nIs member\n\n\nThe \njsonpath-member\n action checks that the element pointed by \npath\n is defined in \nobject\n. Returns a boolean.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nobject\n\n\naction\n\n\nNo\n\n\nYes\n\n\nAction that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.\n\n\n\n\n\n\npath\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nJSONPath\n\n\n\n\n\n\n\n\nExample\n\n\n{\njsonpath-member\n : {\n                       \npath\n :  \nbody.customer.active_card.type\n\n                     }\n}\n\n\n\n\nAre members\n\n\nThe \njsonpath-members\n action checks that the elements pointed by \npaths\n are defined in \nobject\n. Returns a boolean.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nobject\n\n\naction\n\n\nNo\n\n\nYes\n\n\nAction that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.\n\n\n\n\n\n\npaths\n\n\nlist of string\n\n\nYes\n\n\nNo\n\n\nList of JSONPathath\n\n\n\n\n\n\n\n\nExample\n\n\n{\njsonpath-members\n : {\n                        \npaths\n :  [\nbody.customer.active_card.type\n,\n                                    \nbody.customer.active_card.exp_month\n]\n                      }\n}\n\n\n\n\nValue\n\n\nThe \njsonpath-value\n action checks that the element pointed by \npath\n in \nobject\n contains the value of \nvalue\n. Returns a boolean.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nobject\n\n\naction\n\n\nNo\n\n\nYes\n\n\nAction that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.\n\n\n\n\n\n\npath\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nJSONPath\n\n\n\n\n\n\nvalue\n\n\njson basic\n\n\nYes\n\n\nNo\n\n\nThe expected JSON value\n\n\n\n\n\n\n\n\nExample\n\n\n{\njsonpath-value\n : {\n                      \npath\n : \ncustomer.active_card.type\n\n                      \nvalue\n : \nVISA\n\n                    }\n}\n\n\n\n\nGet\n\n\nThe \njsonpath-get\n action gets the value pointed by \npath\n in \nobject\n and stores it in the \nvariable\n. The value stored in the variable can be recovered with \nvar-get\n action. If the \npath\n does not exist, an empty binary is returned.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nobject\n\n\naction\n\n\nNo\n\n\nYes\n\n\nAction that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.\n\n\n\n\n\n\npath\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nJSONPath\n\n\n\n\n\n\nvariable\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nVariable name\n\n\n\n\n\n\n\n\nExample\n\n\n{\njsonpath-get\n :   {\n                      \npath\n :  \nbody.customer.active_card.type\n\n                      \nvariable\n : \nCardType\n\n                    }\n}\n\n\n\n\nSet\n\n\nThe \njsonpath-set\n action sets the element pointed by \npath\n in \nobject\n to the value of \nvalue\n. Can be used as the body of a HTTP request.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nobject\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nJSON object represented as a string\n\n\n\n\n\n\npath\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nJSONPath\n\n\n\n\n\n\nvalue\n\n\njson basic\n\n\nYes\n\n\nYes\n\n\nVariable name\n\n\n\n\n\n\n\n\nExample\n\n\n{\njsonpath-set\n : {\n          \nobject\n : \n{\\\ncustomer\\\n : {\\\nactive_card\\\n :\n                                            {\\\ntype\\\n : \\\nVisa\\\n,\n                                             \\\nexp_month\\\n : 6},\n                                       \\\nemail\\\n : \\\nme@me.com\\\n\n                                      }\n                      }\n,\n          \npath\n :  \ncustomer.active_card.type\n\n          \nvalue\n : \nMasterCard\n\n                  }\n}\n\n\n\n\nMultiset\n\n\nThe \njsonpath-multiset\n action sets a list of pairs \n\\{path, value\\\n} on the \nobject\n. The element pointed by \npath\n in object is replaced by \nvalue\n. It can be used as the body of a HTTP request.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nobject\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nJSON object represented as a string\n\n\n\n\n\n\npairs\n\n\nList of pair objects\n\n\nYes\n\n\nNo\n\n\nList of objects containing path and value\n\n\n\n\n\n\n\n\nThe \npair\n action:\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\npath\n\n\nstring\n\n\nYes\n\n\nNo\n\n\nJSONPath\n\n\n\n\n\n\nvalue\n\n\njson basic\n\n\nYes\n\n\nYes\n\n\nVariable name\n\n\n\n\n\n\n\n\nExample\n\n\n{\njsonpath-multiset\n : {\n     \nobject\n : \n{\\\ncustomer\\\n : { \\\nactive_card\\\n :\n                                        {\\\ntype\\\n : \\\nVisa\\\n,\n                                         \\\nexp_month\\\n : 6},\n                                   \\\nemail\\\n : \\\nme@me.com\\\n\n                                 }\n                 }\n,\n     \npairs\n: [\n                {\n                  \npath\n :  \ncustomer.active_card.type\n\n                  \nvalue\n : \nMasterCard\n\n                }\n              ]\n            }\n}", 
            "title": "JSON handling"
        }, 
        {
            "location": "/action_json/#json-handling", 
            "text": "JSONPath actions support JSON manipulation on HTTP requests and responses. HTTP responses are stored in a special variable (see  Variables ) to avoid the user having to store and retrieve on following checks. See  HTTP  for information on the format of the HTTP responses.   Currently, only two kind of queries are allowed with JSONPath:   Nested object/member expressions:  store.book  Array expression:  store.book[1].title  Array index starts at 0  random  chooses a random index in the length of the array:  store.book[random].title     JSONPath will be extended to support more XPath-like expressions.", 
            "title": "JSON handling"
        }, 
        {
            "location": "/action_json/#is-member", 
            "text": "The  jsonpath-member  action checks that the element pointed by  path  is defined in  object . Returns a boolean.     Name  Type  Required  Action  Info      object  action  No  Yes  Action that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.    path  string  Yes  No  JSONPath     Example  { jsonpath-member  : {\n                        path  :   body.customer.active_card.type \n                     }\n}", 
            "title": "Is member"
        }, 
        {
            "location": "/action_json/#are-members", 
            "text": "The  jsonpath-members  action checks that the elements pointed by  paths  are defined in  object . Returns a boolean.     Name  Type  Required  Action  Info      object  action  No  Yes  Action that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.    paths  list of string  Yes  No  List of JSONPathath     Example  { jsonpath-members  : {\n                         paths  :  [ body.customer.active_card.type ,\n                                     body.customer.active_card.exp_month ]\n                      }\n}", 
            "title": "Are members"
        }, 
        {
            "location": "/action_json/#value", 
            "text": "The  jsonpath-value  action checks that the element pointed by  path  in  object  contains the value of  value . Returns a boolean.     Name  Type  Required  Action  Info      object  action  No  Yes  Action that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.    path  string  Yes  No  JSONPath    value  json basic  Yes  No  The expected JSON value     Example  { jsonpath-value  : {\n                       path  :  customer.active_card.type \n                       value  :  VISA \n                    }\n}", 
            "title": "Value"
        }, 
        {
            "location": "/action_json/#get", 
            "text": "The  jsonpath-get  action gets the value pointed by  path  in  object  and stores it in the  variable . The value stored in the variable can be recovered with  var-get  action. If the  path  does not exist, an empty binary is returned.     Name  Type  Required  Action  Info      object  action  No  Yes  Action that evaluates to a JSON object. If it is not present, it will use as input the answer from the last HTTP request.    path  string  Yes  No  JSONPath    variable  string  Yes  No  Variable name     Example  { jsonpath-get  :   {\n                       path  :   body.customer.active_card.type \n                       variable  :  CardType \n                    }\n}", 
            "title": "Get"
        }, 
        {
            "location": "/action_json/#set", 
            "text": "The  jsonpath-set  action sets the element pointed by  path  in  object  to the value of  value . Can be used as the body of a HTTP request.     Name  Type  Required  Action  Info      object  string  Yes  No  JSON object represented as a string    path  string  Yes  No  JSONPath    value  json basic  Yes  Yes  Variable name     Example  { jsonpath-set  : {\n           object  :  {\\ customer\\  : {\\ active_card\\  :\n                                            {\\ type\\  : \\ Visa\\ ,\n                                             \\ exp_month\\  : 6},\n                                       \\ email\\  : \\ me@me.com\\ \n                                      }\n                      } ,\n           path  :   customer.active_card.type \n           value  :  MasterCard \n                  }\n}", 
            "title": "Set"
        }, 
        {
            "location": "/action_json/#multiset", 
            "text": "The  jsonpath-multiset  action sets a list of pairs  \\{path, value\\ } on the  object . The element pointed by  path  in object is replaced by  value . It can be used as the body of a HTTP request.     Name  Type  Required  Action  Info      object  string  Yes  No  JSON object represented as a string    pairs  List of pair objects  Yes  No  List of objects containing path and value     The  pair  action:     Name  Type  Required  Action  Info      path  string  Yes  No  JSONPath    value  json basic  Yes  Yes  Variable name     Example  { jsonpath-multiset  : {\n      object  :  {\\ customer\\  : { \\ active_card\\  :\n                                        {\\ type\\  : \\ Visa\\ ,\n                                         \\ exp_month\\  : 6},\n                                   \\ email\\  : \\ me@me.com\\ \n                                 }\n                 } ,\n      pairs : [\n                {\n                   path  :   customer.active_card.type \n                   value  :  MasterCard \n                }\n              ]\n            }\n}", 
            "title": "Multiset"
        }, 
        {
            "location": "/action_string/", 
            "text": "String handling\n\n\nJoin\n\n\nThe \nstring-join\n action concatenates two or more strings.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nstrings\n\n\nlist of strings\n\n\nYes\n\n\nYes\n\n\nList of strings or actions that evaluate to strings.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nstring-join\n : {\n                   \nstrings\n :  [\n                                  \n/User/Login.do?mac=\n,\n                                  {\nvar-get\n : {\nname\n : \nmac\n}}\n                                ]\n                 }\n}", 
            "title": "String handling"
        }, 
        {
            "location": "/action_string/#string-handling", 
            "text": "", 
            "title": "String handling"
        }, 
        {
            "location": "/action_string/#join", 
            "text": "The  string-join  action concatenates two or more strings.     Name  Type  Required  Action  Info      strings  list of strings  Yes  Yes  List of strings or actions that evaluate to strings.     Example  { string-join  : {\n                    strings  :  [\n                                   /User/Login.do?mac= ,\n                                  { var-get  : { name  :  mac }}\n                                ]\n                 }\n}", 
            "title": "Join"
        }, 
        {
            "location": "/action_math/", 
            "text": "Math\n\n\nrandom\n\n\nThe \nmath-random\n action generates a random integer between \nlower\n and \nupper\n limits.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nupper\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nUpper limit.\n\n\n\n\n\n\nlower\n\n\ninteger\n\n\nYes\n\n\nNo\n\n\nLower limit.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nmath-random\n : {\n                \nupper\n : 10,\n                \nlower\n : 2\n              }\n}\n\n\n\n\nsum\n\n\nThe \nmath-sum\n action sums all the integers given as arguments.\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nRequired\n\n\nAction\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nintegers\n\n\nne-list of integers\n\n\nYes\n\n\nYes\n\n\nList of integers or actions, which must evaluate to an integer.\n\n\n\n\n\n\n\n\nExample\n\n\n{\nmath-sum\n : {\n                \nintegers\n : [10, {\nmath-random\n : {\n                                                    \nupper\n : 10,\n                                                    \nlower\n : 2\n                                                   }\n                                  }\n                             ]\n              }\n}", 
            "title": "Math"
        }, 
        {
            "location": "/action_math/#math", 
            "text": "", 
            "title": "Math"
        }, 
        {
            "location": "/action_math/#random", 
            "text": "The  math-random  action generates a random integer between  lower  and  upper  limits.     Name  Type  Required  Action  Info      upper  integer  Yes  No  Upper limit.    lower  integer  Yes  No  Lower limit.     Example  { math-random  : {\n                 upper  : 10,\n                 lower  : 2\n              }\n}", 
            "title": "random"
        }, 
        {
            "location": "/action_math/#sum", 
            "text": "The  math-sum  action sums all the integers given as arguments.     Name  Type  Required  Action  Info      integers  ne-list of integers  Yes  Yes  List of integers or actions, which must evaluate to an integer.     Example  { math-sum  : {\n                 integers  : [10, { math-random  : {\n                                                     upper  : 10,\n                                                     lower  : 2\n                                                   }\n                                  }\n                             ]\n              }\n}", 
            "title": "sum"
        }, 
        {
            "location": "/escript_test_spec/", 
            "text": "Escript\n\n\nMegaload supports specifying tests by means of an Erlang Escript, as an alternative to JSON files, to test XMPP servers. Escript and JSON test specifications differ in the way they define the activities performed by each worker and in the target load model.\n\n\nThe Escript test specification supported by Megaload is described below. The XMPP client used is the open source library \nescalus\n, developed by Erlang Solutions.\n\n\nAn example is available in \nExamples\n.\n\n\nModel\n\n\nThe Escript must define:\n\n\n\n\nThe function \nmain/1\n, implementing the job each Megaload worker shall perform;\n\n\nTwo callbacks related to updating the target load generated by the Megaload node hitting the system under test (SUT). The target load is modelled as target number of workers and target rate.\n\n\n\n\nThe escript may define:\n\n\n\n\nThe initial targets for the workers and rate.\n\n\nThe arrival rate for all the test.\n\n\nThe total number of unique ids generated by Megaload\n\n\n\n\nWhen instructed to start the load test, Megaload begins spawning short-lived workers -- each executing the \nmain/1\n function, then dying.\nMegaload ends doing so only when instructed to stop the load test.\n\n\nEach Megaload node spawns new workers according to the local target number of workers, and throttles the invocations of the \nmain/1\n function according to the local target rate.\n\n\nEach Megaload node periodically sets the local targets (i.e. target number of workers and target rate) to the values returned by the dedicated load regulation callback, capped in order not to exceed the configured memory and CPU usage limits (configuration parameters \nmem_load_limit\n and \ncpu_load_limit\n of the \nloader_utils\n application).\n\n\nLoad regulation model\n\n\n\n\n\nThe load regulation sets local target load -- i.e. number of workers and rate -- for each Megaload node. On each Megaload node, local mechanisms enforce the local targets.\n\n\nThe load regulation is per-node, i.e. each Megaload node decides the local targets independently from the other Megaload nodes in the cluster, based on custom SUT-related metrics.\n\n\nFor the sake of simplicity, the workers arrival frequency experienced by the SUT in case of Megaload cluster with multiple Megaload nodes is a default value (hardcoded in Megaload) multiplied by the number of Megaload nodes. \n\n\nAt the start of the test, each Megaload node invokes the specified initialization callback supposed to initialize the custom SUT-related metrics.\n\n\nDuring each phase, on each Megaload node, the load regulation periodically:\n\n\n\n\nReads the custom SUT-related metrics;\n\n\nInvokes the specified regulation callback, that returns new local targets (from previous local targets and metrics values);\n\n\nReads memory usage and CPU utilization;\n\n\nComputes and sets new local targets as returned by the regulation callback and capped by memory usage and CPU utilization.\n\n\n\n\nTest specification\n\n\nIntroduction\n\n\nIn order to specify a valid test, the Escript has to define \nmain/1\n and other two callbacks -- there is no need to export them.\n\n\nThe following is a minimal template Escript:\n\n\n#!/usr/bin/env escript\n\nmain(_) -\n\n  %% Hit SUT.\n  %% Update request counters.\n  %% Update custom SUT-related actual metrics.\n  ok.\n\ninit_load_regulation_metrics() -\n\n  %% Initialize target and actual custom SUT-related metrics.\n  InitializedMetrics = [...], %% Non-empty list here.\n  {ok, InitializedMetrics}.\n\nload_regulation_targets(_MetricsValues, OldTargets) -\n\n  %% Compute new targets.\n  NewTargets = OldTargets, %% Dummy logic.\n  {ok, NewTargets}.\n\n\n\n\nIn order to write the Escript, it may be useful relying on Erlang modules not released with plain Megaload. Refer to the Megaload installation guide for how to build a Megaload package with additional applications.\n\n\nDuring development and prototyping:\n\n\n\n\nThe Escript can write entries in the Megaload custom log using the API in the \nloader_custom_log\n module. Such logging must be removed during the actual load testing of the SUT;\n\n\nYou may prefer validating the Escript using \nescript -s\n (warnings can be ignored) before feeding Megaload with it.\n\n\n\n\nJob performed by each worker\n\n\nThe Escript has to define the job to be performed by each worker in the \nmain/1\n function.\n\n\nMain\n\n\nHit the SUT, update request counters, update the custom SUT-related actual metrics (e.g. response time of the SUT) and return.\n\n\nType\n\n\n-callback main(any()) -\n ok.\n\n\n\n\nExpected behaviour\n\n\nIn order to update the request counters, use the Megaload API in the \nloader_requests\n module.\n\n\nIn order to update the custom SUT-related actual metrics, use the Megaload API in the \nloader_metrics\n module.\n\n\nLoad regulation\n\n\n\n\n\nThe Escript has to define two load regulation-related callbacks:\n\n\n\n\nInitialization callback \ninit_load_regulation_metrics/0\n;\n\n\nRegulation callback \nload_regulation_targets/2\n.\n\n\n\n\nInitialization callback\n\n\nInitialize custom SUT-related metrics.\n\n\nThe returned metrics datapoints are read by Megaload in the regulation loop.\n\nIt is guaranteed to be executed on the Megaload node.\n\n\nType\n\n\n-callback init_load_regulation_metrics() -\n {ok, InitializedMetrics}\n  when InitializedMetrics :: [Metric, ...],\n       Metric :: {ShortName, Target, Actual},\n       ShortName :: atom(), %% E.g. time_to_deliver\n       Target :: LoaderMetricsMetric,\n       Actual :: LoaderMetricsMetric,\n       LoaderMetricsMetric :: {Name, DataPoints :: [DataPoint, ...]}.\n\n\n\n\nThe prefix of the returned names should be \n\"load_regulation\"\n, followed by \n\"target\"\n | \n\"actual\"\n and the short name of the metrics e.g. \n\"time_to_deliver\"\n.\n\n\nExpected behaviour\n\n\nA sequence of calls to \nloader_metrics:new_*\n.\n\n\nRegulation callback\n\n\nCompute new proposed targets for number of workers and rate.\n\n\nIt is not guaranteed to be executed on the Megaload node.\n\n\nType\n\n\n-callback load_regulation_targets(MetricsValues, OldTargets) -\n {ok, NewTargets}\n  when MetricsValues :: [MetricValues, ...],\n       MetricValues :: {ShortName, TargetDataValues, ActualDataValues},\n       TargetDataValues :: DataValues,\n       ActualDataValues :: DataValues,\n       DataValues :: [LoaderMetricsDataValue, ...],\n       LoaderMetricsDataValue :: any(),\n       OldTargets :: Targets,\n       NewTargets :: Targets,\n       Targets :: {{workers, TargetWorkers}, {rate, TargetRate}},\n       TargetWorkers :: pos_integer(),\n       TargetRate :: pos_integer().\n\n\n\n\nExpected behaviour\n\n\nPurely functional logic (i.e. deterministic and free of side effects) e.g. it shall not attempt to read metrics.\n\n\nRate, workers, arrival rate and unique ids\n\n\nThe initial values for rate and workers, and the value of the arrival rate for all the test may be defined using Erlang attributes.\nIf these are missing, they default to:\n\n\n\n\nrate = 1, the load regulation will increase this value based on available CPU\n\n\nworkers = 1, the load regulation will increase this value based on available memory\n\n\narrival_rate = 20\n\n\n\n\nThe unique ids may be used by an Erlang escript to have a unique integer identifier on each concurrent scenario. As an example, this identifier can be used in XMPP to generate unique user/password pairs. The unique id is stored in the process dictionary and can be retrieved using \nerlang:get(unique_id)\n.\n\n\nThe total number of unique identifiers is split among nodes to avoid duplicates. By default, Megaload will assign 1,000,000 unique identifiers per node. As an example, two nodes with 15000 unique ids are split such as one node has identifier 1 to 7499 and the other identifier 7500 to 15000. Note that if a node needs more identifiers than provided, it may generate duplicates by overlapping ids with other nodes.\n\n\nExample\n\n\n-rate(15). %% requests per second\n-workers(150). %% concurrent_scenarios in the JSON specification\n-arrival_rate(20). %% new workers/scenarios per second\n-unique_ids(15000).", 
            "title": "Escript test specification"
        }, 
        {
            "location": "/escript_test_spec/#escript", 
            "text": "Megaload supports specifying tests by means of an Erlang Escript, as an alternative to JSON files, to test XMPP servers. Escript and JSON test specifications differ in the way they define the activities performed by each worker and in the target load model.  The Escript test specification supported by Megaload is described below. The XMPP client used is the open source library  escalus , developed by Erlang Solutions.  An example is available in  Examples .", 
            "title": "Escript"
        }, 
        {
            "location": "/escript_test_spec/#model", 
            "text": "The Escript must define:   The function  main/1 , implementing the job each Megaload worker shall perform;  Two callbacks related to updating the target load generated by the Megaload node hitting the system under test (SUT). The target load is modelled as target number of workers and target rate.   The escript may define:   The initial targets for the workers and rate.  The arrival rate for all the test.  The total number of unique ids generated by Megaload   When instructed to start the load test, Megaload begins spawning short-lived workers -- each executing the  main/1  function, then dying.\nMegaload ends doing so only when instructed to stop the load test.  Each Megaload node spawns new workers according to the local target number of workers, and throttles the invocations of the  main/1  function according to the local target rate.  Each Megaload node periodically sets the local targets (i.e. target number of workers and target rate) to the values returned by the dedicated load regulation callback, capped in order not to exceed the configured memory and CPU usage limits (configuration parameters  mem_load_limit  and  cpu_load_limit  of the  loader_utils  application).  Load regulation model   The load regulation sets local target load -- i.e. number of workers and rate -- for each Megaload node. On each Megaload node, local mechanisms enforce the local targets.  The load regulation is per-node, i.e. each Megaload node decides the local targets independently from the other Megaload nodes in the cluster, based on custom SUT-related metrics.  For the sake of simplicity, the workers arrival frequency experienced by the SUT in case of Megaload cluster with multiple Megaload nodes is a default value (hardcoded in Megaload) multiplied by the number of Megaload nodes.   At the start of the test, each Megaload node invokes the specified initialization callback supposed to initialize the custom SUT-related metrics.  During each phase, on each Megaload node, the load regulation periodically:   Reads the custom SUT-related metrics;  Invokes the specified regulation callback, that returns new local targets (from previous local targets and metrics values);  Reads memory usage and CPU utilization;  Computes and sets new local targets as returned by the regulation callback and capped by memory usage and CPU utilization.", 
            "title": "Model"
        }, 
        {
            "location": "/escript_test_spec/#test-specification", 
            "text": "Introduction  In order to specify a valid test, the Escript has to define  main/1  and other two callbacks -- there is no need to export them.  The following is a minimal template Escript:  #!/usr/bin/env escript\n\nmain(_) - \n  %% Hit SUT.\n  %% Update request counters.\n  %% Update custom SUT-related actual metrics.\n  ok.\n\ninit_load_regulation_metrics() - \n  %% Initialize target and actual custom SUT-related metrics.\n  InitializedMetrics = [...], %% Non-empty list here.\n  {ok, InitializedMetrics}.\n\nload_regulation_targets(_MetricsValues, OldTargets) - \n  %% Compute new targets.\n  NewTargets = OldTargets, %% Dummy logic.\n  {ok, NewTargets}.  In order to write the Escript, it may be useful relying on Erlang modules not released with plain Megaload. Refer to the Megaload installation guide for how to build a Megaload package with additional applications.  During development and prototyping:   The Escript can write entries in the Megaload custom log using the API in the  loader_custom_log  module. Such logging must be removed during the actual load testing of the SUT;  You may prefer validating the Escript using  escript -s  (warnings can be ignored) before feeding Megaload with it.   Job performed by each worker  The Escript has to define the job to be performed by each worker in the  main/1  function.  Main  Hit the SUT, update request counters, update the custom SUT-related actual metrics (e.g. response time of the SUT) and return.  Type  -callback main(any()) -  ok.  Expected behaviour  In order to update the request counters, use the Megaload API in the  loader_requests  module.  In order to update the custom SUT-related actual metrics, use the Megaload API in the  loader_metrics  module.  Load regulation   The Escript has to define two load regulation-related callbacks:   Initialization callback  init_load_regulation_metrics/0 ;  Regulation callback  load_regulation_targets/2 .   Initialization callback  Initialize custom SUT-related metrics.  The returned metrics datapoints are read by Megaload in the regulation loop. \nIt is guaranteed to be executed on the Megaload node.  Type  -callback init_load_regulation_metrics() -  {ok, InitializedMetrics}\n  when InitializedMetrics :: [Metric, ...],\n       Metric :: {ShortName, Target, Actual},\n       ShortName :: atom(), %% E.g. time_to_deliver\n       Target :: LoaderMetricsMetric,\n       Actual :: LoaderMetricsMetric,\n       LoaderMetricsMetric :: {Name, DataPoints :: [DataPoint, ...]}.  The prefix of the returned names should be  \"load_regulation\" , followed by  \"target\"  |  \"actual\"  and the short name of the metrics e.g.  \"time_to_deliver\" .  Expected behaviour  A sequence of calls to  loader_metrics:new_* .  Regulation callback  Compute new proposed targets for number of workers and rate.  It is not guaranteed to be executed on the Megaload node.  Type  -callback load_regulation_targets(MetricsValues, OldTargets) -  {ok, NewTargets}\n  when MetricsValues :: [MetricValues, ...],\n       MetricValues :: {ShortName, TargetDataValues, ActualDataValues},\n       TargetDataValues :: DataValues,\n       ActualDataValues :: DataValues,\n       DataValues :: [LoaderMetricsDataValue, ...],\n       LoaderMetricsDataValue :: any(),\n       OldTargets :: Targets,\n       NewTargets :: Targets,\n       Targets :: {{workers, TargetWorkers}, {rate, TargetRate}},\n       TargetWorkers :: pos_integer(),\n       TargetRate :: pos_integer().  Expected behaviour  Purely functional logic (i.e. deterministic and free of side effects) e.g. it shall not attempt to read metrics.  Rate, workers, arrival rate and unique ids  The initial values for rate and workers, and the value of the arrival rate for all the test may be defined using Erlang attributes.\nIf these are missing, they default to:   rate = 1, the load regulation will increase this value based on available CPU  workers = 1, the load regulation will increase this value based on available memory  arrival_rate = 20   The unique ids may be used by an Erlang escript to have a unique integer identifier on each concurrent scenario. As an example, this identifier can be used in XMPP to generate unique user/password pairs. The unique id is stored in the process dictionary and can be retrieved using  erlang:get(unique_id) .  The total number of unique identifiers is split among nodes to avoid duplicates. By default, Megaload will assign 1,000,000 unique identifiers per node. As an example, two nodes with 15000 unique ids are split such as one node has identifier 1 to 7499 and the other identifier 7500 to 15000. Note that if a node needs more identifiers than provided, it may generate duplicates by overlapping ids with other nodes.  Example  -rate(15). %% requests per second\n-workers(150). %% concurrent_scenarios in the JSON specification\n-arrival_rate(20). %% new workers/scenarios per second\n-unique_ids(15000).", 
            "title": "Test specification"
        }, 
        {
            "location": "/escript_api/", 
            "text": "Megaload Escript API\n\n\nThe Erlang API described in this chapter provides the functionality required by Erlang scripts to create or update metrics inside Megaload.\n\n\nloader_requests\n\n\nErlang module\n\n\nAPI for counting requests.\n\nA request is either invalid or valid - this can be determined before the sending the request to the system under test.\n\nA valid request is either successful or failed - this can be determined only after having sent the request to the system under test.\n\n\nExports\n\n\n\n\n\n\ninc_failed() -\n term()\n\n  Increment counter of failed valid requests.\n\n\n\n\n\n\ninc_invalid() -\n term()\n\n  Increment counter of invalid requests.\n\n\n\n\n\n\ninc_successful() -\n term()\n\n  Increment counter of successful valid requests.\n\n\n\n\n\n\nloader_metrics\n\n\nErlang module\n\n\nThis module is a generic API for loader metrics. The API is used by the loader and it is meant to be used by the plugins and escripts as well.\n\n\nData types\n\n\nname() = [binary()]\noption() = {highest_trackable_value, integer()} | {significant_figures, 1..5}\n| {periodic, integer()} | {external, name()} | {uniform, name()}\noptions() = [option()]\n\n\n\n\nExports\n\n\n\n\n\n\nnew_counter(Name::name()) -\n ok\n\n  Creates a new counter.\n\n\n\n\n\n\nnew_extended_histogram(Name::name()) -\n ok\n\n  Creates a new Histogram, with associated test and phase histograms.\n\n\n\n\n\n\nnew_gauge(Name::name()) -\n ok\n\n  Creates a new gauge.\n\n\n\n\n\n\nnew_histogram(Name::name()) -\n ok\n\n  Creates a new Histogram with the default options.\n\n\n\n\n\n\nnew_histogram(Name::name(), Opts::options()) -\n ok\n\n  Creates a new Histogram of the given type with the given options.\n\n\n\n\n\n\nupdate_counter(Name::name(), Value::integer()) -\n ok | {error, not_found}\n\n  Updates a counter with the specified value.\n\n\n\n\n\n\nupdate_dyn_counter(Name::name(), Value::integer()) -\n ok\n\n  Updates a counter with the specified value. Creates the counter if it doesn't exist.\n\n\n\n\n\n\nupdate_dyn_histogram_set(Name::name(), Value::number()) -\n ok\n\n  Modifies a histogram by adding a new value and creates two additional histograms: test and phase, used mainly in PBT. These last two histograms are of type uniform to provide totals for the test and phase respectively, while the basic histogram reflects actual values.\n\n  The phase histogram will be retrieved and reset at the end of each phase, so it always contains the values of the current phase.\n\n\n\n\n\n\nupdate_gauge(Name::name(), Value::number()) -\n ok | {error, not_found}\n\n  Updates a gauge by the specified value.\n\n\n\n\n\n\nupdate_histogram(Name::name(), Value::number()) -\n ok | {error, not_found}\n\n  Modifies a Histogram by adding a new value.", 
            "title": "Escript API"
        }, 
        {
            "location": "/escript_api/#megaload-escript-api", 
            "text": "The Erlang API described in this chapter provides the functionality required by Erlang scripts to create or update metrics inside Megaload.", 
            "title": "Megaload Escript API"
        }, 
        {
            "location": "/escript_api/#loader_requests", 
            "text": "Erlang module  API for counting requests. \nA request is either invalid or valid - this can be determined before the sending the request to the system under test. \nA valid request is either successful or failed - this can be determined only after having sent the request to the system under test.  Exports    inc_failed() -  term() \n  Increment counter of failed valid requests.    inc_invalid() -  term() \n  Increment counter of invalid requests.    inc_successful() -  term() \n  Increment counter of successful valid requests.", 
            "title": "loader_requests"
        }, 
        {
            "location": "/escript_api/#loader_metrics", 
            "text": "Erlang module  This module is a generic API for loader metrics. The API is used by the loader and it is meant to be used by the plugins and escripts as well.  Data types  name() = [binary()]\noption() = {highest_trackable_value, integer()} | {significant_figures, 1..5}\n| {periodic, integer()} | {external, name()} | {uniform, name()}\noptions() = [option()]  Exports    new_counter(Name::name()) -  ok \n  Creates a new counter.    new_extended_histogram(Name::name()) -  ok \n  Creates a new Histogram, with associated test and phase histograms.    new_gauge(Name::name()) -  ok \n  Creates a new gauge.    new_histogram(Name::name()) -  ok \n  Creates a new Histogram with the default options.    new_histogram(Name::name(), Opts::options()) -  ok \n  Creates a new Histogram of the given type with the given options.    update_counter(Name::name(), Value::integer()) -  ok | {error, not_found} \n  Updates a counter with the specified value.    update_dyn_counter(Name::name(), Value::integer()) -  ok \n  Updates a counter with the specified value. Creates the counter if it doesn't exist.    update_dyn_histogram_set(Name::name(), Value::number()) -  ok \n  Modifies a histogram by adding a new value and creates two additional histograms: test and phase, used mainly in PBT. These last two histograms are of type uniform to provide totals for the test and phase respectively, while the basic histogram reflects actual values. \n  The phase histogram will be retrieved and reset at the end of each phase, so it always contains the values of the current phase.    update_gauge(Name::name(), Value::number()) -  ok | {error, not_found} \n  Updates a gauge by the specified value.    update_histogram(Name::name(), Value::number()) -  ok | {error, not_found} \n  Modifies a Histogram by adding a new value.", 
            "title": "loader_metrics"
        }, 
        {
            "location": "/rest_api_intro/", 
            "text": "Introduction\n\n\nThe Megaload API is a HTTP interface for the management of all aspects of load testing. Megaload uses HTTP response codes to indicate API errors. JSON will be returned in responses from the API, including errors.\n\n\nfamilyUUID\n\n\nThe argument \nfamilyUUID\n is the identifier of the family of nodes, or Megaload cluster, where the command must be executed.\n\n\nThe list of families can be obtained with the following call:\n\n\nGET /api/topo/node-family\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\n {\n   \nid\n : \nc719a664-83cb-4ab5-b02f-0f91f3e6f512\n,\n   \nname\n : \nmegaload 0.0.1\n,\n   \ndescription\n : []\n }\n]", 
            "title": "Introduction"
        }, 
        {
            "location": "/rest_api_intro/#introduction", 
            "text": "The Megaload API is a HTTP interface for the management of all aspects of load testing. Megaload uses HTTP response codes to indicate API errors. JSON will be returned in responses from the API, including errors.", 
            "title": "Introduction"
        }, 
        {
            "location": "/rest_api_intro/#familyuuid", 
            "text": "The argument  familyUUID  is the identifier of the family of nodes, or Megaload cluster, where the command must be executed.  The list of families can be obtained with the following call:  GET /api/topo/node-family  Example response  Status: 200 OK  [\n {\n    id  :  c719a664-83cb-4ab5-b02f-0f91f3e6f512 ,\n    name  :  megaload 0.0.1 ,\n    description  : []\n }\n]", 
            "title": "familyUUID"
        }, 
        {
            "location": "/rest_api_error/", 
            "text": "Errors\n\n\nMegaload uses conventional HTTP response codes to indicate success or failure of an API request. 2xx codes indicate success, codes in the 4xx range indicate an error related to the provided information (e.g. a parameter was missing, the test is already running, etc.), and codes in the 5xx range indicate an internal error within Megaload. \n\n\nReturns\n\n\nAll REST API calls may return a 409 response code with an error message providing the reason.\n\n\nExample response\n\n\nStatus: 409 Conflict\n\n\n\n\n{\n  \nerror\n : \nCommand cannot be executed in state running\n\n}", 
            "title": "Errors"
        }, 
        {
            "location": "/rest_api_error/#errors", 
            "text": "Megaload uses conventional HTTP response codes to indicate success or failure of an API request. 2xx codes indicate success, codes in the 4xx range indicate an error related to the provided information (e.g. a parameter was missing, the test is already running, etc.), and codes in the 5xx range indicate an internal error within Megaload.", 
            "title": "Errors"
        }, 
        {
            "location": "/rest_api_error/#returns", 
            "text": "All REST API calls may return a 409 response code with an error message providing the reason.", 
            "title": "Returns"
        }, 
        {
            "location": "/rest_api_error/#example-response", 
            "text": "Status: 409 Conflict  {\n   error  :  Command cannot be executed in state running \n}", 
            "title": "Example response"
        }, 
        {
            "location": "/rest_api_runner/", 
            "text": "Runner\n\n\nStart load\n\n\nPOST /api/megaload/start_load/:familyUUID\n\n\n\n\nInput\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nTest identifier\n\n\n\n\n\n\n\n\nExample\n\n\n{\nid\n : \ntest-1\n}\n\n\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/start_load/c719a664-83cb-4ab5-b02f-0f91f3e6f512  --data \n{\\\nid\\\n : \\\ntest-1\\\n}\n --header \nContent-Type: application/json\n\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{}\n\n\n\n\nStop load\n\n\nPOST /api/megaload/stop_load/:familyUUID\n\n\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/stop_load/c719a664-83cb-4ab5-b02f-0f91f3e6f512  --data \n --header \nContent-Type: application/json\n\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{}\n\n\n\n\nIs test running\n\n\nGET /api/megaload/is_running/:familyUUID\n\n\n\n\nReturns\n\n\nThe current state of the Megaload cluster and the test identifier (if applies). Possible states are: \nrunning\n | \nstopping\n | \nstopped\n | \nfinishing\n | \nfinished\n | \nstandby\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/is_running/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{\nstate\n : \nrunning\n,\n \nid\n : \ntest-1\n}", 
            "title": "Runner"
        }, 
        {
            "location": "/rest_api_runner/#runner", 
            "text": "", 
            "title": "Runner"
        }, 
        {
            "location": "/rest_api_runner/#start-load", 
            "text": "POST /api/megaload/start_load/:familyUUID  Input     Name  Type  Info      id  string  Test identifier     Example  { id  :  test-1 }  Example request  curl http://localhost:8080/api/megaload/start_load/c719a664-83cb-4ab5-b02f-0f91f3e6f512  --data  {\\ id\\  : \\ test-1\\ }  --header  Content-Type: application/json   Example response  Status: 200 OK  {}", 
            "title": "Start load"
        }, 
        {
            "location": "/rest_api_runner/#stop-load", 
            "text": "POST /api/megaload/stop_load/:familyUUID  Example request  curl http://localhost:8080/api/megaload/stop_load/c719a664-83cb-4ab5-b02f-0f91f3e6f512  --data   --header  Content-Type: application/json   Example response  Status: 200 OK  {}", 
            "title": "Stop load"
        }, 
        {
            "location": "/rest_api_runner/#is-test-running", 
            "text": "GET /api/megaload/is_running/:familyUUID  Returns  The current state of the Megaload cluster and the test identifier (if applies). Possible states are:  running  |  stopping  |  stopped  |  finishing  |  finished  |  standby  Example request  curl http://localhost:8080/api/megaload/is_running/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  { state  :  running ,\n  id  :  test-1 }", 
            "title": "Is test running"
        }, 
        {
            "location": "/rest_api_configuration/", 
            "text": "Upload configuration\n\n\nUpload test specification\n\n\nTest specifications can be written and composed from different files. The load configuration call allows you to provision this configuration on each node.\n\nThe test specifications are parsed at this point and any error in the syntax will be noted in the response. Validation of the content is done on \nstart_load\n, to ensure all required phases, scenarios and plugins are defined in the system.\n\n\nPOST /api/megaload/upload_config_file/:familyUUID\n\n\n\n\nInput\n\n\nHTTP multipart request with \nContent-Type : application/json\n\n\nExample\n\n\n-----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name=\nfiles[]\n; filename=\ntest.json\n\nContent-Type: application/json\n\n[ {\nphase\n : {\nid\n : \nphase-1\n,\n              \narrival_rate\n : 10,\n              \nduration\n : 30000,\n              \nconcurrent_scenarios\n : 10,\n              \nrate\n : 10,\n              \nscenarios\n : [{\nmain-page\n : 1}]\n             }\n  }\n]\n\n-----------------------------18036622772727284871017578311--\n\n\n\n\nReturns\n\n\nIf the test specification is invalid, it returns a 409 response code with an error message explaining the reason.\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{}\n\n\n\n\nClear test specification\n\n\nClear all tests specifications in the system. If a test is running, it will not clear the specification and return and error.\n\n\nPOST /api/megaload/clear_config_file/:familyUUID\n\n\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/clear_config_load/c719a664-83cb-4ab5-b02f-0f91f3e6f512  --data \n --header \nContent-Type: application/json\n\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{}\n\n\n\n\nUpload additional data\n\n\nSome tests may require additional information from the user. This information can be provided in the form of CSV files that must be provisioned in the system.\n\n\nThe name to be used in the test must be provided when the file is uploaded through Megaload-UI.\n\n\nPOST /api/megaload/upload_data_file/:familyUUID\n\n\n\n\nInput\n\n\nHTTP multipart request with \nContent-Type : application/octet-stream\n\n\nExample\n\n\n-----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name=\nfiles[]\n; filename=\nusers.csv\n\nContent-Type: octet-stream\n\nuser1,password1\nuser2,password2\nuser3,password3\n\n-----------------------------18036622772727284871017578311--\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{}\n\n\n\n\nUpload actions module\n\n\nSome tests may require additional actions provided by the user. This is the case of property-based testing where they can define custom generators.\n\n\nModules defining actions can be uploaded from this interface. They are compiled in every Megaload node and compilation errors are reported. If a module with the same name exists in core Megaload, this call reports an error. If another action module with the same name was uploaded through this call, it is replaced.\n\n\nPOST /api/megaload/upload_actions_file/:familyUUID\n\n\n\n\nInput\n\n\nHTTP multipart request with \nContent-Type : application/octet-stream\n\n\nExample\n\n\n-----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name=\nfiles[]\n; filename=\nml_integer.erl\n\nContent-Type: application/octet-stream\n\n-module(ml_integer).\n-behaviour(loader_action).\n\n-export([\n   validation_spec/1,\n   post_validation/1,\n   increase/3\n  ]).\n\n-record('integer-increase', {value}).\n\n-compile({parse_transform, exprecs}).\n\n-export_records(['integer-increase']).\n\n%%%===================================================================\n%%% Configuration callbacks\n%%%===================================================================\nvalidation_spec('integer-increase') -\n\n    [{value, mandatory, integer, false}].\n\npost_validation(_) -\n\n    fun(V) -\n V end.\n\n%%%===================================================================\n%%% Plugin actions\n%%%===================================================================\n-spec increase(#'integer-increase'{}, loader_run:global_test_id(), undefined) -\n\n      {ok, integer(), undefined}.\nincrease(#'integer-increase'{value = Value}, GlobalTestId, undefined) -\n\n    {ok, Value + 1, undefined}.\n\n-----------------------------18036622772727284871017578311--\n\n\n\n\nReturns\n\n\nIf the module exists or is invalid, it returns a 409 response code with an error message explaining the reason.\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{}\n\n\n\n\nUpload property module\n\n\nPOST /api/megaload/upload_property_file/:familyUUID\n\n\n\n\nInput\n\n\nHTTP multipart request with \nContent-Type : application/octet-stream\n\n\nExample\n\n\n-----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name=\nfiles[]\n; filename=\nquickcheck_prop.erl\n\nContent-Type: application/octet-stream\n\n-module(quickcheck_prop).\n\n-include_lib(\neqc/include/eqc.hrl\n).\n\n-compile(export_all).\n\nprop_load() -\n\n    ?FORALL(Users, eqc_loadtest:linear(10, 100),\n        begin\n            {ok, ok} = loader:update_phase(\nphase1\n,\n                                           [{\nconcurrent_scenarios\n, Users}]),\n            case loader:start_load(\ntest\n) of\n                {ok,ok} -\n\n                    loader_pbt:wait_until_terminated(),\n                    {ok, Requests} = loader:get_counter(\n                                           \nhttp_counter_totalRequests\n),\n                    Requests \n 1000;\n                Other -\n\n                    false\n                end\n        end).\n\n-----------------------------18036622772727284871017578311--\n\n\n\n\nReturns\n\n\nIf the module is invalid, it returns a 409 response code with an error message explaining the reason.\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{}", 
            "title": "Upload configuration"
        }, 
        {
            "location": "/rest_api_configuration/#upload-configuration", 
            "text": "", 
            "title": "Upload configuration"
        }, 
        {
            "location": "/rest_api_configuration/#upload-test-specification", 
            "text": "Test specifications can be written and composed from different files. The load configuration call allows you to provision this configuration on each node. \nThe test specifications are parsed at this point and any error in the syntax will be noted in the response. Validation of the content is done on  start_load , to ensure all required phases, scenarios and plugins are defined in the system.  POST /api/megaload/upload_config_file/:familyUUID  Input  HTTP multipart request with  Content-Type : application/json  Example  -----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name= files[] ; filename= test.json \nContent-Type: application/json\n\n[ { phase  : { id  :  phase-1 ,\n               arrival_rate  : 10,\n               duration  : 30000,\n               concurrent_scenarios  : 10,\n               rate  : 10,\n               scenarios  : [{ main-page  : 1}]\n             }\n  }\n]\n\n-----------------------------18036622772727284871017578311--  Returns  If the test specification is invalid, it returns a 409 response code with an error message explaining the reason.  Example response  Status: 200 OK  {}", 
            "title": "Upload test specification"
        }, 
        {
            "location": "/rest_api_configuration/#clear-test-specification", 
            "text": "Clear all tests specifications in the system. If a test is running, it will not clear the specification and return and error.  POST /api/megaload/clear_config_file/:familyUUID  Example request  curl http://localhost:8080/api/megaload/clear_config_load/c719a664-83cb-4ab5-b02f-0f91f3e6f512  --data   --header  Content-Type: application/json   Example response  Status: 200 OK  {}", 
            "title": "Clear test specification"
        }, 
        {
            "location": "/rest_api_configuration/#upload-additional-data", 
            "text": "Some tests may require additional information from the user. This information can be provided in the form of CSV files that must be provisioned in the system.  The name to be used in the test must be provided when the file is uploaded through Megaload-UI.  POST /api/megaload/upload_data_file/:familyUUID  Input  HTTP multipart request with  Content-Type : application/octet-stream  Example  -----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name= files[] ; filename= users.csv \nContent-Type: octet-stream\n\nuser1,password1\nuser2,password2\nuser3,password3\n\n-----------------------------18036622772727284871017578311--  Example response  Status: 200 OK  {}", 
            "title": "Upload additional data"
        }, 
        {
            "location": "/rest_api_configuration/#upload-actions-module", 
            "text": "Some tests may require additional actions provided by the user. This is the case of property-based testing where they can define custom generators.  Modules defining actions can be uploaded from this interface. They are compiled in every Megaload node and compilation errors are reported. If a module with the same name exists in core Megaload, this call reports an error. If another action module with the same name was uploaded through this call, it is replaced.  POST /api/megaload/upload_actions_file/:familyUUID  Input  HTTP multipart request with  Content-Type : application/octet-stream  Example  -----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name= files[] ; filename= ml_integer.erl \nContent-Type: application/octet-stream\n\n-module(ml_integer).\n-behaviour(loader_action).\n\n-export([\n   validation_spec/1,\n   post_validation/1,\n   increase/3\n  ]).\n\n-record('integer-increase', {value}).\n\n-compile({parse_transform, exprecs}).\n\n-export_records(['integer-increase']).\n\n%%%===================================================================\n%%% Configuration callbacks\n%%%===================================================================\nvalidation_spec('integer-increase') - \n    [{value, mandatory, integer, false}].\n\npost_validation(_) - \n    fun(V) -  V end.\n\n%%%===================================================================\n%%% Plugin actions\n%%%===================================================================\n-spec increase(#'integer-increase'{}, loader_run:global_test_id(), undefined) - \n      {ok, integer(), undefined}.\nincrease(#'integer-increase'{value = Value}, GlobalTestId, undefined) - \n    {ok, Value + 1, undefined}.\n\n-----------------------------18036622772727284871017578311--  Returns  If the module exists or is invalid, it returns a 409 response code with an error message explaining the reason.  Example response  Status: 200 OK  {}", 
            "title": "Upload actions module"
        }, 
        {
            "location": "/rest_api_configuration/#upload-property-module", 
            "text": "POST /api/megaload/upload_property_file/:familyUUID  Input  HTTP multipart request with  Content-Type : application/octet-stream  Example  -----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name= files[] ; filename= quickcheck_prop.erl \nContent-Type: application/octet-stream\n\n-module(quickcheck_prop).\n\n-include_lib( eqc/include/eqc.hrl ).\n\n-compile(export_all).\n\nprop_load() - \n    ?FORALL(Users, eqc_loadtest:linear(10, 100),\n        begin\n            {ok, ok} = loader:update_phase( phase1 ,\n                                           [{ concurrent_scenarios , Users}]),\n            case loader:start_load( test ) of\n                {ok,ok} - \n                    loader_pbt:wait_until_terminated(),\n                    {ok, Requests} = loader:get_counter(\n                                            http_counter_totalRequests ),\n                    Requests   1000;\n                Other - \n                    false\n                end\n        end).\n\n-----------------------------18036622772727284871017578311--  Returns  If the module is invalid, it returns a 409 response code with an error message explaining the reason.  Example response  Status: 200 OK  {}", 
            "title": "Upload property module"
        }, 
        {
            "location": "/rest_api_escript/", 
            "text": "Escript handling\n\n\nUpload escript\n\n\nPOST /api/megaload/upload_escript_file/:familyUUID\n\n\n\n\nInput\n\n\nHTTP multipart request with \nContent-Type : application/octet-stream\n\n\nExample\n\n\n-----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name=\nfiles[]\n; filename=\nempty.es\n\nContent-Type: application/octet-stream\n\n#!/usr/bin/env escript\n\nmain([]) -\n\n    ok.\n\ninit_load_regulation_metrics() -\n\n    {ok, []}.\n\nload_regulation_targets(_Metrics, OldTargets) -\n\n    {ok, OldTargets}.\n\n-----------------------------18036622772727284871017578311--\n\n\n\n\nReturns\n\n\nThe identifier generated by Megaload for the uploaded escript. If the escript is invalid, it returns a 409 response code with an error message explaining the reason.\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\nescript_test_1421315152830\n\n\n\n\n\nGet all escript filenames\n\n\nGET /api/megaload/escripts/:familyUUID\n\n\n\n\nReturns\n\n\nList of escript filenames. The filename, without extension, is the identifier generated by Megaload on the upload of the escript.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/escripts/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\nmegaload_escript_1421314324910.es\n, \nmegaload_escript_1421314325432.es\n]\n\n\n\n\nGet escript file\n\n\nGET /api/megaload/escript/:familyUUID/:escriptFilename\n\n\n\n\nReturns\n\n\nThe escript file in binary format.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/escript/c719a664-83cb-4ab5-b02f-0f91f3e6f512/megaload_escript_1421314325432.es\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n#!/usr/bin/env escript\n\nmain([]) -\n\n    ok.\n\ninit_load_regulation_metrics() -\n\n    {ok, []}.\n\nload_regulation_targets(_Metrics, OldTargets) -\n\n    {ok, OldTargets}.", 
            "title": "Escript handling"
        }, 
        {
            "location": "/rest_api_escript/#escript-handling", 
            "text": "", 
            "title": "Escript handling"
        }, 
        {
            "location": "/rest_api_escript/#upload-escript", 
            "text": "POST /api/megaload/upload_escript_file/:familyUUID  Input  HTTP multipart request with  Content-Type : application/octet-stream  Example  -----------------------------18036622772727284871017578311\nContent-Disposition: form-data; name= files[] ; filename= empty.es \nContent-Type: application/octet-stream\n\n#!/usr/bin/env escript\n\nmain([]) - \n    ok.\n\ninit_load_regulation_metrics() - \n    {ok, []}.\n\nload_regulation_targets(_Metrics, OldTargets) - \n    {ok, OldTargets}.\n\n-----------------------------18036622772727284871017578311--  Returns  The identifier generated by Megaload for the uploaded escript. If the escript is invalid, it returns a 409 response code with an error message explaining the reason.  Example response  Status: 200 OK  escript_test_1421315152830", 
            "title": "Upload escript"
        }, 
        {
            "location": "/rest_api_escript/#get-all-escript-filenames", 
            "text": "GET /api/megaload/escripts/:familyUUID  Returns  List of escript filenames. The filename, without extension, is the identifier generated by Megaload on the upload of the escript.  Example request  curl http://localhost:8080/api/megaload/escripts/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  [ megaload_escript_1421314324910.es ,  megaload_escript_1421314325432.es ]", 
            "title": "Get all escript filenames"
        }, 
        {
            "location": "/rest_api_escript/#get-escript-file", 
            "text": "GET /api/megaload/escript/:familyUUID/:escriptFilename  Returns  The escript file in binary format.  Example request  curl http://localhost:8080/api/megaload/escript/c719a664-83cb-4ab5-b02f-0f91f3e6f512/megaload_escript_1421314325432.es  Example response  Status: 200 OK  #!/usr/bin/env escript\n\nmain([]) - \n    ok.\n\ninit_load_regulation_metrics() - \n    {ok, []}.\n\nload_regulation_targets(_Metrics, OldTargets) - \n    {ok, OldTargets}.", 
            "title": "Get escript file"
        }, 
        {
            "location": "/rest_api_reporting/", 
            "text": "Reporting\n\n\nGet all test identifiers\n\n\nGET /api/megaload/all_tests/:familyUUID\n\n\n\n\nReturns\n\n\nList of test identifiers\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/all_tests/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\ntest-1\n, \ntest-2\n]\n\n\n\n\nGet all phase identifiers\n\n\nPOST /api/megaload/phases/:familyUUID\n\n\n\n\nInput\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nInfo\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nTest identifier\n\n\n\n\n\n\n\n\nExample\n\n\n{ \nid\n : \ntest-1\n }\n\n\n\n\nReturns\n\n\nList of phase identifiers for a given test.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/phases/c719a664-83cb-4ab5-b02f-0f91f3e6f512 --data \n{\\\nid\\\n : \\\ntest-1\\\n}\n --header \nContent-Type: application/json\n\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\nphase-1\n, \nphase-2\n]\n\n\n\n\nGet test assertions report\n\n\nGET /api/megaload/test_report/:familyUUID\n\n\n\n\nReturns\n\n\nThe summary of the status of the test and phase assertions. Returns: the global success status, the test identifier, the test assertions status, and a list of the status of the assertions on each phase.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/test_report/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{\n  \nphase_assert\n : [\n                    {\n                      \nid\n : \nphase-1\n,\n                      \nposition\n : 1,\n                      \nsuccess\n : true\n                    },\n                    {\n                      \nid\n : \nphase-2\n,\n                      \nposition\n : 2,\n                      \nsuccess\n : true\n                    }\n                   ],\n  \ntest_assert\n : true,\n  \ntest\n : \ntest-1\n,\n  \nsuccess\n : true\n}\n\n\n\n\nGet test assertion details\n\n\nGET /api/megaload/test_info/:familyUUID\n\n\n\n\nReturns\n\n\nThe details of the test assertions.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/test_info/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{\n  \nassertions\n :\n     [\n      {\n        \njson\n : { \nassert-counter\n : { \nid\n : \nglobal_counter_successfulRequests\n,\n                                        \nmetric\n : \ncount\n,\n                                        \nfilter\n : { \ngt\n: 0 }}\n                 },\n        \nstatus\n : true,\n        \nvalue\n : 387\n      },\n      {\n        \njson\n : { \nassert-counter\n : { \nid\n : \nglobal_counter_failedRequests\n,\n                                        \nmetric\n : \ncount\n,\n                                        \nfilter\n : {\neq\n : 0}}\n                 },\n        \nstatus\n : true,\n        \nvalue\n : 0\n      }\n     ],\n  \nid\n : \ntest-1\n\n}\n\n\n\n\nGet phase assertion details\n\n\nGET /api/megaload/phase_info/:familyUUID/:phasePosition\n\n\n\n\nInput\n\n\nThe phase position is the position returned in the get all phases request.\n\n\nReturns\n\n\nThe details of the phase assertions.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/phase_info/c719a664-83cb-4ab5-b02f-0f91f3e6f512/1\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n{\n  \nassertions\n :\n     [\n      {\n        \njson\n : { \nassert-counter\n : { \nid\n : \nglobal_counter_failedRequests\n,\n                                        \nmetric\n : \ncount\n,\n                                        \nfilter\n : {\neq\n:0}}\n                 },\n        \nstatus\n : true,\n        \nvalue\n : 0\n      },\n      {\n        \njson\n : { \nassert-histogram\n : { \nid\n : \nhttp_histogram_responseTime\n,\n                                          \nstatistic\n : \nmean\n,\n                                          \nfilter\n : {\nlt\n:500000}}\n                 },\n        \nstatus\n : true,\n        \nvalue\n : 79569.54380664653\n      }\n     ],\n  \nid\n : \nphase-2\n,\n  \nposition\n : 2\n}\n\n\n\n\nGet response time statistics\n\n\nGET /api/megaload/stat_response_time/:familyUUID\n\n\n\n\nReturns\n\n\nThe statistics for the response time on each available protocol. HTTP only.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/stat_response_time/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\n {\n   \nprotocol\n : \nhttp\n,\n   \ndata\n : {\n              \nmean\n : 82405,\n              \nmin\n : 48690,\n              \nmax\n : 473296,\n              \nmedian\n : 81439,\n              \npercentile\n : [{ \nindex\n : 50, \nvalue\n : 81439 },\n                              { \nindex\n : 75, \nvalue\n : 89824 },\n                              { \nindex\n : 90, \nvalue\n : 104831 },\n                              { \nindex\n : 95, \nvalue\n : 120023 },\n                              { \nindex\n : 99, \nvalue\n : 159389 },\n                              { \nindex\n : 999, \nvalue\n : 473296 }]\n            }\n }\n]\n\n\n\n\nGet response time statistics per URL\n\n\nGET /api/megaload/stat_response_time_per_url/:familyUUID\n\n\n\n\nReturns\n\n\nThe average response time per URL. HTTP only.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/stat_response_time_per_url/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\n {\n   \npath\n : \n/\n,\n   \nhost\n : \n74.125.230.247\n,\n   \nmean\n : 82404.7803617571\n }\n]\n\n\n\n\nGet rate statistics\n\n\nGET /api/megaload/stat_rate/:familyUUID\n\n\n\n\nReturns\n\n\nThe statistics for the global rate in requests per second. It includes all protocols.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/stat_rate/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\n {\n   \npath\n : \n/\n,\n   \nhost\n : \n74.125.230.247\n,\n   \nmean\n : 82404.7803617571\n }\n]\n\n\n\n\nGet configuration\n\n\nGET /api/megaload/get_configuration/:familyUUID\n\n\n\n\nReturns\n\n\nThe test configuration stored in Megaload. Returns all tests, phases, scenarios and plugins in JSON format on a single file.\n\n\nExample request\n\n\ncurl http://localhost:8080/api/megaload/get_configuration/c719a664-83cb-4ab5-b02f-0f91f3e6f512\n\n\n\n\nExample response\n\n\nStatus: 200 OK\n\n\n\n\n[\n { \ntest\n : { \nid\n : \ntest-1\n,\n            \nphases\n : [\nphase-1\n],\n            \nplugins\n : [\nserver-under-test\n] }\n },\n { \nplugin\n : { \nid\n : \nserver-under-test\n,\n             \nplugin_info\n : {\nhttp-plugin\n : { \nservers\n : [{ \nhost\n : \n127.0.0.1\n,\n                                                     \nport\n : 80,\n                                                   \nssl\n : false }]\n                                      }\n                         }\n           }\n },\n { \nphase\n : { \nid\n : \nphase-1\n,\n             \narrival_rate\n : 10,\n             \nduration\n : 30000,\n             \nconcurrent_scenarios\n : 1,\n             \nrate\n : 5,\n             \nscenarios\n : [ { \nmain-page\n : 1 } ]}\n },\n {\nscenario\n : { \nid\n : \nmain-page\n,\n             \nactions\n : [ \n                {\nhttp-request\n : {\nplugin_id\n : \nSUT_server\n,\n                               \nmethod\n : \nGET\n,\n                               \npath\n : \n/\n,\n                                       \nheaders\n : {\nCookie\n : \nPREF=ID=1345ds2345d3\n,\n                                                    \nConnection\n : \nkeep-alive\n},\n                                       \nassert_status\n : \n200\n}}\n                         ]\n             }\n }\n]", 
            "title": "Reporting"
        }, 
        {
            "location": "/rest_api_reporting/#reporting", 
            "text": "", 
            "title": "Reporting"
        }, 
        {
            "location": "/rest_api_reporting/#get-all-test-identifiers", 
            "text": "GET /api/megaload/all_tests/:familyUUID  Returns  List of test identifiers  Example request  curl http://localhost:8080/api/megaload/all_tests/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  [ test-1 ,  test-2 ]", 
            "title": "Get all test identifiers"
        }, 
        {
            "location": "/rest_api_reporting/#get-all-phase-identifiers", 
            "text": "POST /api/megaload/phases/:familyUUID  Input     Name  Type  Info      id  string  Test identifier     Example  {  id  :  test-1  }  Returns  List of phase identifiers for a given test.  Example request  curl http://localhost:8080/api/megaload/phases/c719a664-83cb-4ab5-b02f-0f91f3e6f512 --data  {\\ id\\  : \\ test-1\\ }  --header  Content-Type: application/json   Example response  Status: 200 OK  [ phase-1 ,  phase-2 ]", 
            "title": "Get all phase identifiers"
        }, 
        {
            "location": "/rest_api_reporting/#get-test-assertions-report", 
            "text": "GET /api/megaload/test_report/:familyUUID  Returns  The summary of the status of the test and phase assertions. Returns: the global success status, the test identifier, the test assertions status, and a list of the status of the assertions on each phase.  Example request  curl http://localhost:8080/api/megaload/test_report/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  {\n   phase_assert  : [\n                    {\n                       id  :  phase-1 ,\n                       position  : 1,\n                       success  : true\n                    },\n                    {\n                       id  :  phase-2 ,\n                       position  : 2,\n                       success  : true\n                    }\n                   ],\n   test_assert  : true,\n   test  :  test-1 ,\n   success  : true\n}", 
            "title": "Get test assertions report"
        }, 
        {
            "location": "/rest_api_reporting/#get-test-assertion-details", 
            "text": "GET /api/megaload/test_info/:familyUUID  Returns  The details of the test assertions.  Example request  curl http://localhost:8080/api/megaload/test_info/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  {\n   assertions  :\n     [\n      {\n         json  : {  assert-counter  : {  id  :  global_counter_successfulRequests ,\n                                         metric  :  count ,\n                                         filter  : {  gt : 0 }}\n                 },\n         status  : true,\n         value  : 387\n      },\n      {\n         json  : {  assert-counter  : {  id  :  global_counter_failedRequests ,\n                                         metric  :  count ,\n                                         filter  : { eq  : 0}}\n                 },\n         status  : true,\n         value  : 0\n      }\n     ],\n   id  :  test-1 \n}", 
            "title": "Get test assertion details"
        }, 
        {
            "location": "/rest_api_reporting/#get-phase-assertion-details", 
            "text": "GET /api/megaload/phase_info/:familyUUID/:phasePosition  Input  The phase position is the position returned in the get all phases request.  Returns  The details of the phase assertions.  Example request  curl http://localhost:8080/api/megaload/phase_info/c719a664-83cb-4ab5-b02f-0f91f3e6f512/1  Example response  Status: 200 OK  {\n   assertions  :\n     [\n      {\n         json  : {  assert-counter  : {  id  :  global_counter_failedRequests ,\n                                         metric  :  count ,\n                                         filter  : { eq :0}}\n                 },\n         status  : true,\n         value  : 0\n      },\n      {\n         json  : {  assert-histogram  : {  id  :  http_histogram_responseTime ,\n                                           statistic  :  mean ,\n                                           filter  : { lt :500000}}\n                 },\n         status  : true,\n         value  : 79569.54380664653\n      }\n     ],\n   id  :  phase-2 ,\n   position  : 2\n}", 
            "title": "Get phase assertion details"
        }, 
        {
            "location": "/rest_api_reporting/#get-response-time-statistics", 
            "text": "GET /api/megaload/stat_response_time/:familyUUID  Returns  The statistics for the response time on each available protocol. HTTP only.  Example request  curl http://localhost:8080/api/megaload/stat_response_time/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  [\n {\n    protocol  :  http ,\n    data  : {\n               mean  : 82405,\n               min  : 48690,\n               max  : 473296,\n               median  : 81439,\n               percentile  : [{  index  : 50,  value  : 81439 },\n                              {  index  : 75,  value  : 89824 },\n                              {  index  : 90,  value  : 104831 },\n                              {  index  : 95,  value  : 120023 },\n                              {  index  : 99,  value  : 159389 },\n                              {  index  : 999,  value  : 473296 }]\n            }\n }\n]", 
            "title": "Get response time statistics"
        }, 
        {
            "location": "/rest_api_reporting/#get-response-time-statistics-per-url", 
            "text": "GET /api/megaload/stat_response_time_per_url/:familyUUID  Returns  The average response time per URL. HTTP only.  Example request  curl http://localhost:8080/api/megaload/stat_response_time_per_url/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  [\n {\n    path  :  / ,\n    host  :  74.125.230.247 ,\n    mean  : 82404.7803617571\n }\n]", 
            "title": "Get response time statistics per URL"
        }, 
        {
            "location": "/rest_api_reporting/#get-rate-statistics", 
            "text": "GET /api/megaload/stat_rate/:familyUUID  Returns  The statistics for the global rate in requests per second. It includes all protocols.  Example request  curl http://localhost:8080/api/megaload/stat_rate/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  [\n {\n    path  :  / ,\n    host  :  74.125.230.247 ,\n    mean  : 82404.7803617571\n }\n]", 
            "title": "Get rate statistics"
        }, 
        {
            "location": "/rest_api_reporting/#get-configuration", 
            "text": "GET /api/megaload/get_configuration/:familyUUID  Returns  The test configuration stored in Megaload. Returns all tests, phases, scenarios and plugins in JSON format on a single file.  Example request  curl http://localhost:8080/api/megaload/get_configuration/c719a664-83cb-4ab5-b02f-0f91f3e6f512  Example response  Status: 200 OK  [\n {  test  : {  id  :  test-1 ,\n             phases  : [ phase-1 ],\n             plugins  : [ server-under-test ] }\n },\n {  plugin  : {  id  :  server-under-test ,\n              plugin_info  : { http-plugin  : {  servers  : [{  host  :  127.0.0.1 ,\n                                                      port  : 80,\n                                                    ssl  : false }]\n                                      }\n                         }\n           }\n },\n {  phase  : {  id  :  phase-1 ,\n              arrival_rate  : 10,\n              duration  : 30000,\n              concurrent_scenarios  : 1,\n              rate  : 5,\n              scenarios  : [ {  main-page  : 1 } ]}\n },\n { scenario  : {  id  :  main-page ,\n              actions  : [ \n                { http-request  : { plugin_id  :  SUT_server ,\n                                method  :  GET ,\n                                path  :  / ,\n                                        headers  : { Cookie  :  PREF=ID=1345ds2345d3 ,\n                                                     Connection  :  keep-alive },\n                                        assert_status  :  200 }}\n                         ]\n             }\n }\n]", 
            "title": "Get configuration"
        }, 
        {
            "location": "/resources/", 
            "text": "Additional resources\n\n\nProduct flyer\n\n\nMegaload Load Testing Tool\n\n\nWebinar\n\n\nThe Age of Load Testing\n\n\nTutorials\n\n\nScalable load testing using properties\n presented at Erlang User Conference 2015.\n\n\nLoad Testing Made Easy\n presented at Erlang User Conference 2014.", 
            "title": "Additional resources"
        }, 
        {
            "location": "/resources/#additional-resources", 
            "text": "", 
            "title": "Additional resources"
        }, 
        {
            "location": "/resources/#product-flyer", 
            "text": "Megaload Load Testing Tool", 
            "title": "Product flyer"
        }, 
        {
            "location": "/resources/#webinar", 
            "text": "The Age of Load Testing", 
            "title": "Webinar"
        }, 
        {
            "location": "/resources/#tutorials", 
            "text": "Scalable load testing using properties  presented at Erlang User Conference 2015.  Load Testing Made Easy  presented at Erlang User Conference 2014.", 
            "title": "Tutorials"
        }, 
        {
            "location": "/about/", 
            "text": "The PROWESS project\n\n\nWe acknowledge the European Commission for its support of the \nPROWESS project\n, Framework 7 project 317820.\n\n\nAbout Erlang Solutions\n\n\nWe develop and build trusted, fault-tolerant systems that can scale to billions of users. We free our partners from operational complexity so they can focus on their business growth. We worked with over 300 clients, from startups to Fortune 100 companies. We\u2019re a talented team of software experts, passionate about Erlang and with an unwavering belief in the open-source future. We have offices in London, Stockholm, Krakow, Copenhagen, Aarhus, Amsterdam, Budapest, Zurich, San Francisco and Buenos Aires.\n\n\nContact us\n\n\nt: +44 (0) 2074 561020\n\n\ne: \nmegaload@erlang-solutions.com\n\n\nw: \nwww.erlang-solutions.com", 
            "title": "About"
        }, 
        {
            "location": "/about/#the-prowess-project", 
            "text": "We acknowledge the European Commission for its support of the  PROWESS project , Framework 7 project 317820.", 
            "title": "The PROWESS project"
        }, 
        {
            "location": "/about/#about-erlang-solutions", 
            "text": "We develop and build trusted, fault-tolerant systems that can scale to billions of users. We free our partners from operational complexity so they can focus on their business growth. We worked with over 300 clients, from startups to Fortune 100 companies. We\u2019re a talented team of software experts, passionate about Erlang and with an unwavering belief in the open-source future. We have offices in London, Stockholm, Krakow, Copenhagen, Aarhus, Amsterdam, Budapest, Zurich, San Francisco and Buenos Aires.", 
            "title": "About Erlang Solutions"
        }, 
        {
            "location": "/about/#contact-us", 
            "text": "t: +44 (0) 2074 561020  e:  megaload@erlang-solutions.com  w:  www.erlang-solutions.com", 
            "title": "Contact us"
        }
    ]
}